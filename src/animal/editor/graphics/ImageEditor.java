package animal.editor.graphics;import animal.editor.Editor;import animal.editor.graphics.meta.AbstractImageEditor;import animal.graphics.PTGraphicObject;import animal.graphics.PTImage;import animal.misc.EditPoint;import animal.misc.EditableObject;import animal.misc.MSMath;import java.awt.*;public class ImageEditor extends AbstractImageEditor {    private static final long serialVersionUID = 2L;    public ImageEditor() {        super();    }    protected void buildGUI() {        // basic setup: central panel        PTImage go = (PTImage)getCurrentObject(false);        Color c = (go == null) ? Color.BLACK : go.getColor();        createImageComponentChooser(c, "color");        // ugly but important - make sure "colorChooser" is set!        // NOTE: this is only for "straight" color objects, not for those        // using embedded texts        colorChooser = ColorChooser;        finishEditor(cp);    }    /**     *     * @see #nextPoint     */    public int pointsNeeded() {        return 2;    }    /**     * sets one of the Image's points. <br>     * 1st and 2nd: set Location(by this, the Image is not displayed before the     * mouse is clicked once)<br>     */    public boolean nextPoint(int num, Point p) {        PTImage t = (PTImage) getCurrentObject();        switch (num) {            case 1:                t.setPosition(p);            case 2:                t.scaleFromNewPoint(p);                break;        }        return true;    } // nextPoint;    /**     * returns the minimal distance from point <i>p</i> to the Image. IMPORTANT:     * use <code>PTGraphicObject</code> as first parameter and cast it to a     * PTImage inside the method. Otherwise this method won't be called.     */    public int getMinDist(PTGraphicObject go, Point p) {        return MSMath.dist(p, go.getBoundingBox());    }    /**     * returns the EditPoints of the Image. Again, the parameter has to be of type     * <b>PTGraphicObject</b>.     *     */    public EditPoint[] getEditPoints(PTGraphicObject go) {        PTImage image = (PTImage) go;        Rectangle bb = image.getBoundingBox();        int width = (int) bb.getWidth();        int height = (int) bb.getHeight();        int x = bb.x;        int y = bb.y;        EditPoint[] result = new EditPoint[5];        Point helper = new Point(x + width, y + height);        result[0] = new EditPoint(2, helper);        result[1] = new EditPoint(-2, new Point(x + (width / 2), y));        result[2] = new EditPoint(-3, new Point(x + width, y + (height / 2)));        result[3] = new EditPoint(-4, new Point(x + (width / 2), y + height));        result[4] = new EditPoint(-5, new Point(x, y + (height / 2)));        return result;    } // getEditPoints    /**     * creates a new Text and uses the attributes of this Editor as default     * values.     */    public EditableObject createObject() {        PTImage image = new PTImage();        storeAttributesInto(image);        return image;    }    /**     * creates a secondary Editor for the given <b>EditableObject</b> and copies     * all of the object's attributes into the components. We can rely on this     * object always being a <b>PTImage</b>.     */    public Editor getSecondaryEditor(EditableObject go) {        ImageEditor result = new ImageEditor();        result.extractAttributesFrom(go);        return result;    }    protected void storeAttributesInto(EditableObject eo) {        super.storeAttributesInto(eo);        PTImage ptgo = (PTImage) eo;        if(!textField.getText().equals(""))            ptgo.setRotation(Double.parseDouble(textField.getText()) % 360);    }    protected void extractAttributesFrom(EditableObject eo) {        super.extractAttributesFrom(eo);        PTImage t = (PTImage) eo;        textField.setText(String.valueOf(t.getRotation()));    }    public String getBasicType() {        return PTImage.IMAGE_TYPE;    }}