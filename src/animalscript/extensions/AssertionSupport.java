package animalscript.extensions;

import java.io.IOException;
import java.io.StreamTokenizer;
import java.util.Hashtable;

import animal.misc.MessageDisplay;
import animal.misc.ParseSupport;
import animal.misc.XProperties;
import animalscript.core.AnimalParseSupport;
import animalscript.core.AnimalScriptInterface;
import animalscript.core.BasicParser;

/**
 * This class provides an import filter for AnimalScript assertion commands
 * 
 * @author <a href="mailto:roessling@acm.org">Guido R&ouml;&szlig;ling</a>
 * @version 1.0 2000-05-20
 */
public class AssertionSupport extends BasicParser implements
		AnimalScriptInterface {
	// ========================= attributes =========================

	/**
	 * instantiates the key class dispatcher mapping keyword to definition type
	 */
	public AssertionSupport() {
		handledKeywords = new Hashtable<String, Object>();
		rulesHash = new XProperties();

		handledKeywords.put("variable", "parseVariableDeclaration");
		rulesHash.put("variable", "variable <id>");

		handledKeywords.put("assign", "parseVariableAssignment");
		rulesHash.put("assign", "assign <id> = <double> | \"text\"");

		handledKeywords.put("assert", "parseAssertion");
		handledKeywords.put("check", "parseAssertion");
		rulesHash.put("assert", "assert <expression>");
		rulesHash.put("check", "see rule for 'assert'");
		rulesHash
				.put(
						"<expression>",
						"<id> | \"text\" | <expression> && <expression> | <expression> || <expression> | <expression> <comparator> <expression>");
		rulesHash.put("<comparator>", "< | <= | == | > | >= | !=");
	}

	// ===================================================================
	// interface methods
	// ===================================================================

	/**
	 * Determine depending on the command passed if a new step is needed Also keep
	 * in mind that we might be in a grouped step using the {...} form. Usually,
	 * every command not inside such a grouped step is contained in a new step.
	 * However, this is not the case for operations without visible effect -
	 * mostly maintenance or declaration entries.
	 * 
	 * @param command
	 *          the command used for the decision.
	 * @return true if a new step must be generated
	 */
	public boolean generateNewStep(String command) {
		return false;
	}

	// ===================================================================
	// Animator parsing routines
	// ===================================================================

	/**
	 * Define a new variable from the description read from the StreamTokenizer.
	 * The description is usually generated by other programs and dumped in a file
	 * or on System.out.
	 */
	public void parseVariableDeclaration() throws IOException {
		String variableName; // variable type and name

		// read in object type
		ParseSupport.parseWord(stok, "Variable declaration type")
				.toLowerCase();

		// read in OID(object name)
		variableName = AnimalParseSupport.parseText(stok, "Variable object name");

		if (ParseSupport.parseOptionalWord(stok, "variable type keyword 'type'",
				"type")) {
			if (ParseSupport.parseOptionalWord(stok, "variable type", "int"))
				getObjectProperties().put(variableName + ".subType", "int");
			else if (ParseSupport.parseOptionalWord(stok, "variable type", "double"))
				getObjectProperties().put(variableName + ".subType", "double");
			else if (ParseSupport.parseOptionalWord(stok, "variable type", "String"))
				getObjectProperties().put(variableName + ".subType", STRING_TYPE);
		}

		// stuff such as typing may follow later on...!
		getObjectProperties().put(variableName + ".value", "0");
		getObjectTypes().put(variableName, getTypeIdentifier("variable"));
	}

	/**
	 * Assign a value to the variable read from the StreamTokenizer. The
	 * description is usually generated by other programs and dumped in a file or
	 * on System.out.
	 * 
	 * 
	 * <br />
	 * Syntax: <code>assign "variableID" = "value"</code> or <code>assign
	 * "variableID" = double</code>
	 */
	public void parseVariableAssignment() throws IOException {
//		String localType; // variable definition type
		String variableName; // name of the variable
		String variableValue; // name of the variable

		// read in object type
		ParseSupport.parseWord(stok, "Variable assignment type")
				.toLowerCase();

		// read in OID(object name)
		variableName = AnimalParseSupport.parseText(stok, "Variable name");

		ParseSupport.parseMandatoryChar(stok, "assignment '=' operator", '=');

		double numericValue = ParseSupport.parseOptionalNumber(stok,
				"variable assignment value");
		if (numericValue != Double.MAX_VALUE) {
			variableValue = String.valueOf(numericValue);
			getObjectProperties().put(variableName + ".type", NUMERIC_TYPE);
		} else {
			variableValue = AnimalParseSupport.parseText(stok, "Variable value");
			getObjectProperties().put(variableName + ".type", STRING_TYPE);
		}
		getObjectProperties().put(variableName + ".value", variableValue);
	}

	private static final int IDENTITY = 0; 
	private static final int EQUALS = 1;
	private static final int LESS_THAN = 2;
	private static final int GREATER_THAN = 4; 
	
//	private static final int STRING_MATCH = 32;
	private static final int INEQUALITY = 16;
	
//	private static final int CASE_STRING_MATCH = 8; 
	private static final int AND = 64; 
	private static final int OR = 128;

	private static final String NUMERIC_TYPE = "numeric", STRING_TYPE = "String";

	/**
	 * Parse data structure-specific operations, such as array element swapping
	 * 
	 */
	public void parseAssertion() throws IOException {
		int operator = IDENTITY;
		ParseSupport.parseWord(stok,
				"data structure-specific operator");// stok.sval;
		String variableName, compValue;
		StringBuilder operatorString = new StringBuilder(200);
		boolean result = false, connectorIsAnd = true, useConnector = false, lastResult = false;

		// generic expression support is beyond me for now!
		// restricted to 'assert "ID" == "String" | value', 'assert "ID" != "String"
		// | value'

		while (stok.nextToken() != StreamTokenizer.TT_EOL) {
			stok.pushBack();
			if (ParseSupport.parseOptionalChar(stok, "assertion operator '&&'", '&')) {
				ParseSupport.parseMandatoryChar(stok, "assertion operator '&&'", '&');
				operator = AND;
				connectorIsAnd = true;
				useConnector = true;
				operatorString.append(" && ");
			} else if (ParseSupport.parseOptionalChar(stok,
					"assertion operator '||'", '|')) {
				ParseSupport.parseMandatoryChar(stok, "assertion operator '||'", '|');
				operator = OR;
				connectorIsAnd = false;
				useConnector = true;
				operatorString.append(" || ");
			} else {
				// read in OID(object name)
				variableName = AnimalParseSupport.parseText(stok, "Variable name");

				operatorString.append(variableName).append(" [");
				operatorString.append(getObjectProperties().getProperty(
						variableName + ".value", "?"));
				operatorString.append("] ");
				if (ParseSupport
						.parseOptionalChar(stok, "assertion operator '=='", '=')) {
					ParseSupport.parseMandatoryChar(stok, "assertion operator '=='", '=');
					operator = IDENTITY;
					operatorString.append("== ");
				} else if (ParseSupport.parseOptionalChar(stok,
						"assertion operator '!='", '!')) {
					ParseSupport.parseMandatoryChar(stok, "assertion operator '!='", '=');
					operator = INEQUALITY;
					operatorString.append("!= ");
				} else if (ParseSupport.parseOptionalChar(stok,
						"assertion operator '< / <='", '<')) {
					operator = LESS_THAN;
					operatorString.append('<');
					if (ParseSupport.parseOptionalChar(stok, "assertion operator '<='",
							'=')) {
						operator += EQUALS;
						operatorString.append('=');
					}
					operatorString.append(' ');
				} else if (ParseSupport.parseOptionalChar(stok,
						"assertion operator '> / >='", '>')) {
					operator = GREATER_THAN;
					operatorString.append('>');
					if (ParseSupport.parseOptionalChar(stok, "assertion operator '>='",
							'=')) {
						operator += EQUALS;
						operatorString.append('=');
					}
					operatorString.append(' ');
				}

				double numberValue = ParseSupport.parseOptionalNumber(stok,
						"comparisonValue");
				if (numberValue != Double.MAX_VALUE) {
					compValue = String.valueOf(numberValue);
					operatorString.append(compValue);
				} else { // might also be object ID --> really support String?
					compValue = AnimalParseSupport.parseText(stok, "Variable value");
					operatorString.append("\"").append(compValue).append("\"");
				}

				String baseValue = getObjectProperties().getProperty(
						variableName + ".value", "0");
				switch (operator) {
				case IDENTITY:
					result = baseValue.equals(compValue);
					break;

				case INEQUALITY:
					result = !baseValue.equals(compValue);
					break;

				case GREATER_THAN:
					result = (baseValue.compareTo(compValue)) > 0;
					break;

				case GREATER_THAN + EQUALS:
					result = (baseValue.compareTo(compValue)) >= 0;
					break;

				case LESS_THAN:
					result = (baseValue.compareTo(compValue)) < 0;
					break;

				case LESS_THAN + EQUALS:
					result = (baseValue.compareTo(compValue)) <= 0;
					break;

				default:
					System.err.println("Don't know what to do with operator "
							+ operatorString.toString());
				}
				if (useConnector) {
					// System.err.print(operatorString.toString() +": " +lastResult +", "
					// +result);
					result = (connectorIsAnd) ? (result && lastResult)
							: (result || lastResult);
					// System.err.println(" ==> " +result);
					useConnector = false;
				}
				lastResult = result;
			}
		}
		stok.pushBack();
		assertionMessage(operatorString.toString(), result);
	}

	private void assertionMessage(String operatorString, boolean assertionResult) {
		MessageDisplay.message("# assertion [" + stok.lineno() + "]: "
				+ operatorString + ((assertionResult) ? " *passed*" : " ***failed***"));
	}

}
