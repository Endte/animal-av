package animalscript.extensions;

import java.awt.Point;
import java.io.IOException;
import java.util.Hashtable;

import animal.graphics.PTGraphicObject;
import animal.graphics.PTPoint;
import animal.graphics.PTPolyline;
import animal.misc.ParseSupport;
import animalscript.core.AnimalParseSupport;
import animalscript.core.AnimalScriptInterface;
import animalscript.core.BasicParser;

/**
 * This class provides an import filter for AnimalScript XXX commands
 * 
 * @author <a href="mailto:roessling@acm.org">Guido R&ouml;&szlig;ling</a>
 * @version 1.0 2000-06-17
 */
public class PropertyChangeSupport extends BasicParser implements
		AnimalScriptInterface {
	// ========================= attributes =========================

	/**
	 * instantiates the key class dispatcher mapping keyword to definition type
	 */
	public PropertyChangeSupport() {
		// Use the following commands in here to instantiate the method
		// callup mechanism:
		// 1. instantiate the local XProperties object
		handledKeywords = new Hashtable<String, Object>();

		// 2. For all handled keywords, associate("put") keyword with method name
		// NOTE: you *must* use lowercase for the whole keyword!!!
		handledKeywords.put("change", "parsePropertyChange");
		handledKeywords.put("changeparam", "parsePropertyChange");
		handledKeywords.put("changeproperty", "parsePropertyChange");
	}

	// ===================================================================
	// interface methods
	// ===================================================================

	/**
	 * Determine depending on the command passed if a new step is needed Also keep
	 * in mind that we might be in a grouped step using the {...} form. Usually,
	 * every command not inside such a grouped step is contained in a new step.
	 * However, this is not the case for operations without visible effect -
	 * mostly maintenance or declaration entries.
	 * 
	 * @param command
	 *          the command used for the decision.
	 * @return true if a new step must be generated
	 */
	public boolean generateNewStep(String command) {
		// adapt the following basic definition to your needs...
		return !sameStep;
	}

	// ===================================================================
	// Animator parsing routines
	// ===================================================================

	/**
	 * Create a array from the description read from the StreamTokenizer. The
	 * description is usually generated by other programs and dumped in a file or
	 * on System.out.
	 */
	public void parsePropertyChange() throws IOException {
		// parse actual keyword encountered(not that it makes a difference...!)
		ParseSupport.parseWord(stok, "property change keyword");

		// parse the raget ID(s)
		String targetName = AnimalParseSupport.parseText(stok,
				"property change target name");
		int[] targetOIDs = getObjectIDs().getIntArrayProperty(targetName);

		// parse the change method
		String methodName = ParseSupport.parseWord(stok, "property change method");

		if (methodName.equalsIgnoreCase("addNode")) {
			Point newPoint = AnimalParseSupport.parseNodeInfo(stok,
					"node to add to object", null);

			for (int i = 0; i < targetOIDs.length; i++) {
				PTGraphicObject go = animState.getCloneByNum(targetOIDs[i]);
				if (go instanceof PTPolyline) {
					((PTPolyline) go).addNode(new PTPoint(newPoint));
				}
			}
		} else if (methodName.equalsIgnoreCase("removeNode")) {
			PTGraphicObject go = animState.getCloneByNum(targetOIDs[0]);
			if (go instanceof PTPolyline) {
				PTPolyline poly = (PTPolyline) go;
				int targetPosition = ParseSupport.parseInt(stok,
						"target index for node removal", 0, poly.getNodeCount() - 1);
				poly.removeNode(targetPosition);
			} else
				System.err.println("Sorry, only possible for PTPolyline objects!");
//		} else if (methodName.equalsIgnoreCase("closed")
//				|| methodName.equalsIgnoreCase("open")
//				|| methodName.equalsIgnoreCase("toggleClosed"))
//			for (int i = 0; i < targetOIDs.length; i++) {
//				PTGraphicObject go = animState.getCloneByNum(targetOIDs[i]);
//				if (go instanceof PTPolyline) {
//					if (methodName.equalsIgnoreCase("closed"))
//						((PTPolyline) go).setClosed(true);
//					else if (methodName.equalsIgnoreCase("open"))
//						((PTPolyline) go).setClosed(true);
//					else
//						((PTPolyline) go).setClosed(!(((PTPolyline) go).isClosed()));
//				}
			}
		else if (methodName.equalsIgnoreCase("fwArrow"))
			for (int i = 0; i < targetOIDs.length; i++) {
				PTGraphicObject go = animState.getCloneByNum(targetOIDs[i]);
				if (go instanceof PTPolyline) {
					PTPolyline p = (PTPolyline) go;
					p.setFWArrow(true);
				}
			}
		else if (methodName.equalsIgnoreCase("bwArrow"))
			for (int i = 0; i < targetOIDs.length; i++) {
				PTGraphicObject go = animState.getCloneByNum(targetOIDs[i]);
				if (go instanceof PTPolyline) {
					PTPolyline p = (PTPolyline) go;
					p.setBWArrow(true);
				}
			}
		else
			System.err.println("Sorry, method is unknown!");
	}

} // class PropertyChangeSupport
