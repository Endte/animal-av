package animalscript.core;

import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Point;
import java.awt.Rectangle;
import java.io.File;
import java.io.IOException;
import java.io.StreamTokenizer;
import java.util.Hashtable;

import javax.swing.JOptionPane;

import animal.graphics.PTArc;
import animal.graphics.PTBoxPointer;
import animal.graphics.PTCircle;
import animal.graphics.PTClosedCircleSegment;
import animal.graphics.PTClosedEllipseSegment;
import animal.graphics.PTEllipse;
import animal.graphics.PTGraphicObject;
import animal.graphics.PTOpenCircleSegment;
import animal.graphics.PTOpenEllipseSegment;
import animal.graphics.PTPoint;
import animal.graphics.PTPolygon;
import animal.graphics.PTPolyline;
import animal.graphics.PTRectangle;
import animal.graphics.PTSquare;
import animal.graphics.PTText;
import animal.graphics.PTTriangle;
import animal.graphics.meta.ArcBasedShape;
import animal.graphics.meta.ArrowablePrimitive;
import animal.graphics.meta.CircularShape;
import animal.graphics.meta.EllipsoidShape;
import animal.graphics.meta.FillablePrimitive;
import animal.graphics.meta.OpenArcBasedShape;
import animal.graphics.meta.OrientedPrimitive;
import animal.graphics.meta.PolygonalShape;
import animal.main.Animal;
import animal.main.AnimalConfiguration;
import animal.misc.ParseSupport;
import animal.misc.XProperties;
import translator.ExtendedResourceBundle;

/**
 * This class provides an import filter for program output to Animal.
 * 
 * @author <a href="mailto:roessling@acm.org">Guido R&ouml;&szlig;ling</a>
 * @version 1.0 1999-06-05
 */
public class BaseObjectParser extends BasicParser
    implements AnimalScriptInterface {
  private String[] registeredLanguages = null;

  /**
   * instantiates the key class dispatcher mapping keyword to definition type
   */
  public BaseObjectParser() {
    handledKeywords = new Hashtable<String, Object>();
    rulesHash = new XProperties();

    handledKeywords.put("arc", "parseArcInput");
    handledKeywords.put("circle", "parseArcBasedInput");
    handledKeywords.put("circleseg", "parseArcBasedInput");
    handledKeywords.put("circlesegment", "parseArcBasedInput");
    handledKeywords.put("ellipseseg", "parseArcBasedInput");
    handledKeywords.put("ellipsesegment", "parseArcBasedInput");
    handledKeywords.put("ellipse", "parseArcBasedInput");

    handledKeywords.put("listelement", "parseListElementInput");

    handledKeywords.put("point", "parsePointInput");

    handledKeywords.put("polyline", "parsePolylineInput");
    handledKeywords.put("line", "parsePolylineInput");

    handledKeywords.put("square", "parseSquareInput");

    handledKeywords.put("rectangle", "parseRectangleInput");
    handledKeywords.put("rect", "parseRectangleInput");
    handledKeywords.put("relrect", "parseRectangleInput");
    handledKeywords.put("relrectangle", "parseRectangleInput");

    handledKeywords.put("triangle", "parseTriangleInput");

    handledKeywords.put("polygon", "parsePolygonInput");

    handledKeywords.put("text", "parseTextInput");

    handledKeywords.put("resource", "parseLanguageSupport");
    handledKeywords.put("supports", "parseLanguageSupport");
  }

  // ===================================================================
  // interface methods
  // ===================================================================

  /**
   * Determine depending on the command passed if a new step is needed Also keep
   * in mind that we might be in a grouped step using the {...} form. Usually,
   * every command not inside such a grouped step is contained in a new step.
   * However, this is not the case for operations without visible effect -
   * mostly maintenance or declaration entries.
   * 
   * Note that this implementation will return <code>false</code> only if the
   * command is embedded in a grouped step.
   * 
   * @param command
   *          the command used for the decision.
   * @return true if a new step must be generated
   */
  public boolean generateNewStep(String command) {
    return !sameStep && !command.equalsIgnoreCase("supports")
        && !command.equalsIgnoreCase("resource");
  }

  // ===================================================================
  // Animator parsing routines
  // ===================================================================

  // ===================================================================
  // Object parsing routines
  // ===================================================================

  /**
   * Create a PTArc from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parseArcInput() throws IOException {
    Point node;
    StringBuilder oids = new StringBuilder();

    PTArc pt = new PTArc();

    // read in object type
    String localType = ParseSupport.parseWord(stok, "Arc type").toLowerCase();

    // read in OID(object name)
    String s = AnimalParseSupport.parseText(stok, "Arc object name");
    pt.setObjectName(s);

    // read in the center node
    pt.setCenter(AnimalParseSupport.parseNodeInfo(stok, localType + " center",
        null));

    // read in keyword 'radius'
    ParseSupport.parseMandatoryWord(stok, localType + " keyword 'radius'",
        "radius");

    pt.setClosed(false);
    pt.setFilled(false);
    boolean completeObjectMode = localType.equalsIgnoreCase("circle")
        || localType.equalsIgnoreCase("ellipse");

    boolean circleType = localType.equalsIgnoreCase("circle")
        || localType.equalsIgnoreCase("circleseg")
        || localType.equalsIgnoreCase("circlesegment");

    // read in radius -- careful, this is a int for circles, else a point
    if (circleType) {
      // set the arc radius to the int value read in
      pt.setRadius(ParseSupport.parseInt(stok, localType + " radius <int>", 1));

      // mark as a circle
      pt.setCircle(true);

      // store the radius in the appropriate property resource
      getObjectProperties().put(localType + ".radius", pt.getXRadius());
    } else { // not a full or partial circle
      // parse the radius as a node first
      node = AnimalParseSupport.parseNodeInfo(stok, localType + " radius node",
          null);

      // set x radius
      pt.setRadius(node);

      // store the x radius
      getObjectProperties().put(localType + ".xRadius", pt.getXRadius());

      // store the y radius
      getObjectProperties().put(localType + ".yRadius", pt.getYRadius());
    }

    // parse optional angle for object segments (if not given, use default)
    if (!completeObjectMode) {
      if (ParseSupport.parseOptionalWord(stok, localType + " keyword 'angle'",
          "angle")) {
        pt.setTotalAngle(ParseSupport.parseInt(stok, localType + " angle"));
        getObjectProperties().put(localType + ".angle", pt.getTotalAngle());
      } else
        pt.setTotalAngle(getObjectProperties().getIntProperty(
            localType + ".angle", 720));

      // check for optional start angle (0 if not given)
      if (ParseSupport.parseOptionalWord(stok, localType + " keyword 'starts'",
          "starts")) {
        pt.setStartAngle(ParseSupport
            .parseInt(stok, localType + " start angle"));
        getObjectProperties()
            .put(localType + ".startAngle", pt.getStartAngle());
      } else
        pt.setStartAngle(getObjectProperties().getIntProperty(
            localType + ".startAngle", 0));

      // check for optional orientation (clockwise / counterclockwise)
      if (ParseSupport.parseOptionalWord(stok, localType
          + " keyword 'clockwise'", "clockwise")) {
        pt.setClockwise(true);
        getObjectProperties().put(localType + ".clockwise", true);
      }
      if (ParseSupport.parseOptionalWord(stok, localType
          + " keyword 'counterclockwise'", "counterclockwise")) {
        pt.setClockwise(false);
        getObjectProperties().put(localType + ".clockwise", false);
      }
    } // incomplete object parameters
    else { // set values for "complete" objects (circle, ellipse)
      pt.setClosed(true);
      pt.setTotalAngle(720);
      pt.setStartAngle(0);
    }

    // parse and set the color
    pt.setColor(AnimalParseSupport.parseAndSetColor(stok, localType, "color"));

    // check for depth information and set it, if available
    AnimalParseSupport.parseAndSetDepth(stok, pt, localType);

    // parse optional attribute 'closed'
    if (!completeObjectMode)
      pt.setClosed(ParseSupport.parseOptionalWord(stok, localType + " closed",
          "closed"));

    // parse optional attribute 'filled'
    if (pt.isClosed()) {
      if (ParseSupport.parseOptionalWord(stok, localType + " filled", "filled")) {
        pt.setFilled(true);

        // parse and set the color
        pt.setFillColor(AnimalParseSupport.parseAndSetColor(stok, localType,
            "fillColor"));
      }
    } else {
      if (ParseSupport.parseOptionalWord(stok, localType + " fw arrow",
          "fwArrow"))
        pt.setFWArrow(true);
      if (ParseSupport.parseOptionalWord(stok, localType + " bw arrow",
          "bwArrow"))
        pt.setBWArrow(true);
    }

    // add the object to the list of graphic objects
    BasicParser.addGraphicObject(pt, anim);

    // append object ID to list
    oids.append(pt.getNum(false));

    // insert into object list -- necessary for lookups later on!
    getObjectIDs().put(s, pt.getNum(false));
    getObjectTypes().put(s, getTypeIdentifier("arc"));
    /*
     * System.err.println(pt.toString() +" closed? " +pt.isClosed() +" filled? "
     * + pt.isFilled() +" cw? " +pt.isClockwise() +" fwArrow? " +pt.hasFWArrow()
     * +" bwArrow? " +pt.hasBWArrow() +" color: " +pt.getColor() +" fillColor:"
     * +pt.getFillColor());
     */
    // display the component, unless marked as 'hidden'
    AnimalParseSupport.showComponents(stok, oids.toString(), localType, true);
  }

  /**
   * Create a PTArc from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parseArcBasedInput() throws IOException {
    int intRadius = 0, totalAngle = 0, startAngle = 0, depth = 0;
    boolean clockwise = true, fwArrow = false, bwArrow = false,
        isClosed = false, isFilled = false;
    Color color = null, fillColor = null;
    Point center = null, pointRadius = null;
    StringBuilder oids = new StringBuilder();

    // create fitting object!
    ArcBasedShape pt = null;
    // PTArc pt = new PTArc();

    // read in object type
    String localType = ParseSupport.parseWord(stok, "Arc type").toLowerCase();

    // read in OID(object name)
    String objectName = AnimalParseSupport.parseText(stok, "Arc object name");

    // read in the center node
    center = AnimalParseSupport.parseNodeInfo(stok, localType + " center",
        null);

    // read in keyword 'radius'
    ParseSupport.parseMandatoryWord(stok, localType + " keyword 'radius'",
        "radius");

    boolean completeObjectMode = localType.equalsIgnoreCase("circle")
        || localType.equalsIgnoreCase("ellipse");

    boolean circleType = localType.equalsIgnoreCase("circle")
        || localType.equalsIgnoreCase("circleseg")
        || localType.equalsIgnoreCase("circlesegment");

    // pt.setObjectName(s);
    // pt.setClosed(false);
    // pt.setFilled(false);
    // read in radius -- careful, this is a int for circles, else a point
    if (circleType) {
      // store the radius to the int value read in
      intRadius = ParseSupport.parseInt(stok, localType + " radius <int>", 1);

      // store the radius in the appropriate property resource
      getObjectProperties().put(localType + ".radius", intRadius);
    } else { // not a full or partial circle
      // parse the radius as a node first
      pointRadius = AnimalParseSupport.parseNodeInfo(stok,
          localType + " radius node", null);

      // set x radius
      // pt.setRadius(node);

      // store the x radius
      getObjectProperties().put(localType + ".xRadius", pointRadius.getX());

      // store the y radius
      getObjectProperties().put(localType + ".yRadius", pointRadius.getY());
    }

    // parse optional angle for object segments (if not given, use default)
    if (!completeObjectMode) {
      if (ParseSupport.parseOptionalWord(stok, localType + " keyword 'angle'",
          "angle")) {
        totalAngle = ParseSupport.parseInt(stok, localType + " angle");
        // pt.setTotalAngle();
        getObjectProperties().put(localType + ".angle", totalAngle);
      } else
      // pt.setTotalAngle(getObjectProperties().getIntProperty(
      // localType + ".angle", 720));

      // check for optional start angle (0 if not given)
      if (ParseSupport.parseOptionalWord(stok, localType + " keyword 'starts'",
          "starts")) {
        startAngle = ParseSupport.parseInt(stok, localType + " start angle");
        // pt.setStartAngle();
        getObjectProperties().put(localType + ".startAngle", startAngle);
      } // else
      // pt.setStartAngle(getObjectProperties().getIntProperty(
      // localType + ".startAngle", 0));

      // check for optional orientation (clockwise / counterclockwise)
      if (ParseSupport.parseOptionalWord(stok,
          localType + " keyword 'clockwise'", "clockwise")) {
        clockwise = true; // pt.setClockwise(true);
        getObjectProperties().put(localType + ".clockwise", true);
      }
      if (ParseSupport.parseOptionalWord(stok,
          localType + " keyword 'counterclockwise'", "counterclockwise")) {
        clockwise = false; // pt.setClockwise(false);
        getObjectProperties().put(localType + ".clockwise", false);
      }
    } // incomplete object parameters
    else { // set values for "complete" objects (circle, ellipse)
      // pt.setClosed(true);
      // pt.setTotalAngle(720);
      // pt.setStartAngle(0);
    }
    // parse and set the color
    color = AnimalParseSupport.parseAndSetColor(stok, localType, "color");

    // check for depth information and set it, if available
    if (ParseSupport.parseOptionalWord(stok, "'depth' tag for " + localType,
        "depth")) {
      // read in next token and if it is a number, set the depth
      if ((stok.nextToken()) == StreamTokenizer.TT_NUMBER)
        depth = (int) stok.nval;
    }
    // AnimalParseSupport.parseAndSetDepth(stok, pt, localType);
   
    // parse optional attribute 'closed'
    if (!completeObjectMode)
      isClosed = ParseSupport.parseOptionalWord(stok, localType + " closed",
          "closed");

    // parse optional attribute 'filled'
    if (completeObjectMode || isClosed) {
      if (ParseSupport.parseOptionalWord(stok, localType + " filled",
          "filled")) {
        isFilled = true; // pt.setFilled(true);

        // parse and set the color
        fillColor = AnimalParseSupport.parseAndSetColor(stok, localType,
            "fillColor");
        // pt.setFillColor
      }
    } else {
      if (ParseSupport.parseOptionalWord(stok, localType + " fw arrow",
          "fwArrow"))
        fwArrow = true; // pt.setFWArrow(true);
      if (ParseSupport.parseOptionalWord(stok, localType + " bw arrow",
          "bwArrow"))
        bwArrow = true; // pt.setBWArrow(true);
    }

    if (localType.equalsIgnoreCase("circle")) {
      pt = new PTCircle();
    } else if (localType.equalsIgnoreCase("ellipse")) { // must be an ellipse
      pt = new PTEllipse();
    } else if (localType.startsWith("circleseg")) {
      if (isClosed) { // closed circle segment
        pt = new PTClosedCircleSegment();
      } else {// open circle segment
        pt = new PTOpenCircleSegment();
      }
    } else if (localType.startsWith("ellipseseg")) {
      if (isClosed) {
        pt = new PTClosedEllipseSegment();
      } else {
        pt = new PTOpenEllipseSegment();
      }
    } else {
      pt = new PTArc();
    }
    // set all shared attributes...
    pt.setObjectName(objectName);
    pt.setDepth(depth);
    pt.setColor(color);
    pt.setCenter(center);
    
    // set special attributes
    if (pt instanceof EllipsoidShape) {
      ((EllipsoidShape)pt).setRadius(pointRadius);
    } else if (pt instanceof CircularShape){
      ((CircularShape)pt).setRadius(intRadius);
    } else if (pt instanceof PTArc) {
      ((PTArc) pt).setRadius(pointRadius);
    }
    if (pt instanceof FillablePrimitive) {
      ((FillablePrimitive) pt).setFilled(isFilled);
      if (isFilled)
        ((FillablePrimitive)pt).setFillColor(fillColor);
    }
    if (pt instanceof OrientedPrimitive) {
      ((OrientedPrimitive) pt).setClockwise(clockwise);
    }
    if (pt instanceof PTArc) {
      ((PTArc)pt).setClosed(isClosed);
    }
    if (pt instanceof OpenArcBasedShape) {
      ((OpenArcBasedShape)pt).setStartAngle(startAngle);
      ((OpenArcBasedShape)pt).setTotalAngle(totalAngle);
    }
    if (pt instanceof ArrowablePrimitive) {
      ((ArrowablePrimitive)pt).setFWArrow(fwArrow);
      ((ArrowablePrimitive)pt).setBWArrow(bwArrow);
    }
   
    // add the object to the list of graphic objects
    BasicParser.addGraphicObject(pt, anim);

    // append object ID to list
    oids.append(pt.getNum(false));

    // insert into object list -- necessary for lookups later on!
    getObjectIDs().put(objectName, pt.getNum(false));
    getObjectTypes().put(objectName, getTypeIdentifier("arc"));
    /*
     * System.err.println(pt.toString() +" closed? " +pt.isClosed() +" filled? "
     * + pt.isFilled() +" cw? " +pt.isClockwise() +" fwArrow? " +pt.hasFWArrow()
     * +" bwArrow? " +pt.hasBWArrow() +" color: " +pt.getColor() +" fillColor:"
     * +pt.getFillColor());
     */
    // display the component, unless marked as 'hidden'
    AnimalParseSupport.showComponents(stok, oids.toString(), localType, true);
  }

  /**
   * Create a PTArc from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parseLanguageSupport() throws IOException {
    String localType = ParseSupport.parseWord(stok, "language command")
        .toLowerCase();
    if (localType.equals("supports")) {
      registeredLanguages = ParseSupport.parseOIDs(stok, null, false);
      chooseLanguage();
    } else if (localType.equals("resource") || localType.equals("bundle")
        || localType.equals("resourcebundle")) {
      String bundleFileName = AnimalParseSupport.parseText(stok,
          "Resource base filename");
      if (bundleFileName.indexOf(File.separatorChar) == -1
          && AnimalConfiguration.getDefaultConfiguration()
              .getCurrentDirectory() != null)
        bundleFileName = AnimalConfiguration.getDefaultConfiguration()
            .getCurrentDirectory() + System.getProperty("file.separator")
            + bundleFileName;
      ParseSupport.setResourceBundle(
          new ExtendedResourceBundle(bundleFileName + "." + chosenLanguage));
    }
  }

  /**
   * Read in a PTBoxPointer object from the ASCII file provided The description
   * is usually generated by other programs and dumped in a file or on
   * System.out.
   */
  public void parseListElementInput() throws IOException {
    /*
     * This probably needs some more work to be really nice...
     */
    int i = 1; // , token = 0;
    Point upperLeftBorder;
    StringBuilder oids = new StringBuilder();
    String textContained = null;
    PTBoxPointer ptBoxPointer = null;

    // read in object type
    String localType = ParseSupport.parseWord(stok, "ListElement type")
        .toLowerCase();

    // read in OID(object name)
    String s = AnimalParseSupport.parseText(stok, "ListElement object name");

    upperLeftBorder = AnimalParseSupport.parseNodeInfo(stok,
        localType + " left boundary", null);
    // older version without parseOptionalOffset:
    // upperLeftBorder = parseStartPosition(localType);

    // parse optional text component
    if (ParseSupport.parseOptionalWord(stok, localType + " keyword 'text'",
        "text")) {
      // read in the text contained
      textContained = AnimalParseSupport.parseText(stok,
          localType + " text component", null, false, chosenLanguage);
    }

    // generate the object with or without text, depending on the definition
    if (textContained != null)
      ptBoxPointer = new PTBoxPointer(upperLeftBorder.x, upperLeftBorder.y,
          textContained);
    else
      ptBoxPointer = new PTBoxPointer(upperLeftBorder.x, upperLeftBorder.y);
    ptBoxPointer.getTextComponent()
        .setFont(new Font("SansSerif", Font.PLAIN, 16));
    ptBoxPointer.setObjectName(s);

    // Next, read in the number of pointers
    ParseSupport.parseMandatoryWord(stok, localType + " keyword 'pointers'",
        "pointers");

    ptBoxPointer.setPointerCount(
        ParseSupport.parseInt(stok, localType + " nr pointers", 0, 255));

    // parse the optional pointer position
    if (ParseSupport.parseOptionalWord(stok, localType + " keyword 'position'",
        "position")) {
      String pos = ParseSupport.parseWord(stok, localType + " pointer position")
          .toLowerCase();

      if (pos.equalsIgnoreCase("top"))
        ptBoxPointer.setPointerPosition(PTBoxPointer.POINTER_POSITION_TOP);
      else if (pos.equalsIgnoreCase("left"))
        ptBoxPointer.setPointerPosition(PTBoxPointer.POINTER_POSITION_LEFT);
      else if (pos.equalsIgnoreCase("none"))
        ptBoxPointer.setPointerPosition(PTBoxPointer.POINTER_POSITION_NONE);
      else if (pos.equalsIgnoreCase("right"))
        ptBoxPointer.setPointerPosition(PTBoxPointer.POINTER_POSITION_RIGHT);
      else
        ptBoxPointer.setPointerPosition(PTBoxPointer.POINTER_POSITION_BOTTOM); // default
    } else
      ptBoxPointer.setPointerPosition(PTBoxPointer.POINTER_POSITION_BOTTOM);

    // is this really a good idea?
    if (ptBoxPointer.getPointerCount() == 0)
      ptBoxPointer.makeNullPointer();

    // set the tip targets
    for (i = 1; i <= ptBoxPointer.getPointerCount(); i++) {
      // extend this method: should be either '(dx, dy)' or 'to \"id\"'
      if (ParseSupport.parseOptionalWord(stok, localType + " keyword 'ptr'" + i,
          "ptr" + i)) {
        if (ParseSupport.parseOptionalChar(stok, "listelement node '('", '(')
            || ParseSupport.parseOptionalWord(stok,
                "listelement pointer target", "offset")) {
          stok.pushBack();
          ptBoxPointer.setTip(i - 1, AnimalParseSupport.parseNodeInfo(stok,
              "pointer target " + i, null));
          // ptBoxPointer.setTipRelative(i - 1,
          // AnimalParseSupport.parseNodeInfo(
          // stok, "pointer target " + i, null));
        } else {
          ParseSupport.parseMandatoryWord(stok,
              "listelement pointer keyword 'to'", "to");
          String prevOID = AnimalParseSupport.parseText(stok,
              "ListElement previous");
          int targetNr = getObjectIDs().getIntProperty(prevOID);
          PTGraphicObject ptTarget = animState.getCloneByNum(targetNr);
          if (ptTarget != null) {
            Rectangle targetBBox = null;
            if (ptTarget instanceof PTBoxPointer)
              targetBBox = ((PTBoxPointer) ptTarget)
                  .getBoundingBoxWithoutPointers();
            else
              targetBBox = ptTarget.getBoundingBox();
            Point tipOrigin = ptBoxPointer.getTipOrigin(i - 1);
            int dx = targetBBox.x - tipOrigin.x;
            int dy = targetBBox.y - tipOrigin.y;
            if (ptTarget instanceof PTBoxPointer) {
              PTBoxPointer pointer = (PTBoxPointer) ptTarget;
              if (pointer.getPointerCount() >= i)
                dy = pointer.getTipOrigin(i - 1).y - tipOrigin.y;
              else
                dy = pointer.getTipOrigin(0).y - tipOrigin.y;
            }
            if (targetBBox.x < upperLeftBorder.x)
              ptBoxPointer.setTipRelative(i - 1, dx + targetBBox.width, dy);
            else
              ptBoxPointer.setTipRelative(i - 1, dx, dy);
          }
        }
      } else {
        Rectangle pointerArea = ptBoxPointer.getPointerArea().getBoundingBox();
        Point tipOrigin = ptBoxPointer.getTipOrigin(i - 1);
        int dx = tipOrigin.x;
        if (i % 2 == 1)
          dx -= pointerArea.x - 1;
        else
          dx -= pointerArea.x + pointerArea.width - 1;
        ptBoxPointer.setTipRelative(i - 1, dx, 0);
      }
    }

    // parse optional word 'previous'
    if (ParseSupport.parseOptionalWord(stok, localType + " keyword 'prev'",
        "prev")) {
      String prevOID = AnimalParseSupport.parseText(stok,
          "ListElement previous");
      int targetNr = getObjectIDs().getIntProperty(prevOID);
      PTGraphicObject targetObj = animState.getCloneByNum(targetNr);
      if (targetObj != null) {
        Rectangle targetBox = null;
        if (targetObj instanceof PTBoxPointer) {
          PTBoxPointer ref = (PTBoxPointer) targetObj;
          int x = 0, y = ref.getTipOrigin(ref.getPointerCount() - 1).y;
          targetBox = ref.getPointerArea().getBoundingBox();
          x = targetBox.x + targetBox.width;
          ptBoxPointer.setTip(ptBoxPointer.getPointerCount() - 1,
              new Point(x, y));
          // ref.getTipOrigin(ref.getPointerCount() - 1));
        } else {
          ptBoxPointer.setTip(ptBoxPointer.getPointerCount() - 1,
              findPositionFor(targetObj.getBoundingBox(), upperLeftBorder));
          // targetObj.getBoundingBox().getLocation());
          // targetPoint);
          // targetBox = targetObj.getBoundingBox();
        }
        // targetPoint = findPositionFor(targetBox, upperLeftBorder);
        // ptBoxPointer.setTip(ptBoxPointer.getPointerCount()-1,
        // targetPoint);
      }
    }

    // parse optional word 'previous'
    if (ParseSupport.parseOptionalWord(stok, localType + " keyword 'next'",
        "next")) {
      String nextOID = AnimalParseSupport.parseText(stok, "ListElement next");
      int targetNr = getObjectIDs().getIntProperty(nextOID);
      PTGraphicObject targetObj = animState.getCloneByNum(targetNr);
      if (targetObj != null) {
        Rectangle targetBox = null;
        if (targetObj instanceof PTBoxPointer) {
          PTBoxPointer ref = (PTBoxPointer) targetObj;
          int x = 0, y = ref.getTipOrigin(0).y;
          targetBox = ref.getPointerArea().getBoundingBox();
          x = targetBox.x; // + targetBox.width;
          ptBoxPointer.setTip(0, new Point(x, y));
          // ref.getTipOrigin(ref.getPointerCount() - 1));
        } else {
          ptBoxPointer.setTip(0,
              findPositionFor(targetObj.getBoundingBox(), upperLeftBorder));
          // targetObj.getBoundingBox().getLocation());
          // targetPoint);
          // targetBox = targetObj.getBoundingBox();
        }
        // targetPoint = findPositionFor(targetBox, upperLeftBorder);
        // ptBoxPointer.setTip(ptBoxPointer.getPointerCount()-1,
        // targetPoint);
      }
    }

    // read in the colors -- all are optional
    // base color
    Color baseColor = AnimalParseSupport.parseAndSetColor(stok, localType,
        "color");
    ptBoxPointer.setColor(baseColor);
    ptBoxPointer.getTextBox().setColor(baseColor);

    // fill color for the text box
    ptBoxPointer.getTextBox().setFillColor(AnimalParseSupport
        .parseAndSetColor(stok, localType, "boxFillColor", "white"));

    // color for the pointer area
    ptBoxPointer.getPointerArea().setColor(AnimalParseSupport
        .parseAndSetColor(stok, localType, "pointerAreaColor"));

    // fill color for the pointer area
    ptBoxPointer.getPointerArea().setFillColor(AnimalParseSupport
        .parseAndSetColor(stok, localType, "pointerAreaFillColor", "white"));

    // color for the text component
    ptBoxPointer.getTextComponent().setColor(
        AnimalParseSupport.parseAndSetColor(stok, localType, "textColor"));

    // check for depth information and set it, if available
    AnimalParseSupport.parseAndSetDepth(stok, ptBoxPointer, localType);

    // add the object to the list of graphic objects
    BasicParser.addGraphicObject(ptBoxPointer, anim);

    // append object ID to list
    oids.append(ptBoxPointer.getNum(false));

    // insert into object list -- necessary for lookups later on!
    getObjectIDs().put(s, ptBoxPointer.getNum(false));
    getObjectTypes().put(s, getTypeIdentifier("listelement"));

    // display the component, unless marked as 'hidden'
    AnimalParseSupport.showComponents(stok, oids.toString(), localType, true);
  }

  private Point findPositionFor(Rectangle targetObjectBox,
      Point upperLeftBorder) {
    int baseX = upperLeftBorder.x, baseY = upperLeftBorder.y;
    int boxX = targetObjectBox.x, boxY = targetObjectBox.y;
    int height = targetObjectBox.height, width = targetObjectBox.width;
    int x = 0, y = 0;
    // if left of box, point to left side
    if (baseX < boxX) // [0, boxX)
      x = boxX; // point to left side
    else if (baseX < boxX + width) // [boxX, boxX+width)
      x = boxX + (width >> 1); // point to center
    else
      x = boxX + width;

    // determine y value
    if (baseY < boxY) // [0, boxY)
      y = boxY; // point to top
    else if (baseY < boxY + height) // [boxY, boxY + height)
      y = boxY + (height >> 1); // point to center
    else
      // [boxY + height, ...)
      y = boxY + height;

    // adapt for "center"
    if (x == boxX + (width >> 1) && y == boxY + (height >> 1))
      y = boxY;
    return new Point(x, y);
  }

  /**
   * Create a PToint from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parsePointInput() throws IOException {
    StringBuilder oids = new StringBuilder();

    // read in object type
    ParseSupport.parseMandatoryWord(stok, "Point keyword 'point'", "point");

    // read in OID(object name)
    String s = AnimalParseSupport.parseText(stok, "Point object name");

    Point p = AnimalParseSupport.parseNodeInfo(stok,
        "point coordinates / offset", null);
    PTPoint pt = new PTPoint(p.x, p.y, 1);
    pt.setObjectName(s);

    // parse and set the color
    pt.setColor(AnimalParseSupport.parseAndSetColor(stok, "point", "color"));

    // check for depth information and set it, if available
    AnimalParseSupport.parseAndSetDepth(stok, pt, "point");

    // add the object to the list of graphic objects
    BasicParser.addGraphicObject(pt, anim);

    // append the object's ID to the list
    oids.append(pt.getNum(false));

    // insert into object list -- necessary for lookups later on!
    getObjectIDs().put(s, pt.getNum(false));
    getObjectTypes().put(s, getTypeIdentifier("point"));

    // display the component, unless marked as 'hidden'
    AnimalParseSupport.showComponents(stok, oids.toString(), "point", true);
  }

  /**
   * Create a PTPolyline from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parsePolylineInput() throws IOException {
    int i = 1;
    PTPoint node1, node2, node3;
    Point currentNode = null;
    PTPolyline pt = new PTPolyline();
    StringBuilder oids = new StringBuilder();

    // read in object type
    String localType = ParseSupport.parseWord(stok, "Polyline type")
        .toLowerCase();

    // read in OID(object name)
    String s = AnimalParseSupport.parseText(stok, "Polyline object name");

    // parse location specification
    currentNode = AnimalParseSupport.parseNodeInfo(stok, localType + "node 1",
        null);
    node1 = new PTPoint(currentNode);
    pt.addNode(node1);

    // read second node
    currentNode = AnimalParseSupport.parseNodeInfo(stok, localType + "node 2",
        null);
    node2 = new PTPoint(currentNode);
    i++;
    pt.addNode(node2); // add this node!

    // do we have another node...?
    if (ParseSupport.nextTokenIsNodeToken(stok)) {

      currentNode = AnimalParseSupport.parseNodeInfo(stok, localType + "node 3",
          null);
      node3 = new PTPoint(currentNode);
      i++;
      pt.addNode(node3);
      // if not triangle, continue till no more nodes are left.
      if (!localType.equalsIgnoreCase("triangle")) {
        while (ParseSupport.nextTokenIsNodeToken(stok)) {
          i++;
          currentNode = AnimalParseSupport.parseNodeInfo(stok,
              localType + "node " + i, null);
          pt.addNode(new PTPoint(currentNode));
        }
      }
    } // check for additional nodes finished
    else {
      stok.pushBack(); // push back component(NOT node paren)
    }
    pt.setObjectName(s);

    // parse and set the color
    pt.setColor(AnimalParseSupport.parseAndSetColor(stok, localType, "color"));

    // check for depth information and set it, if available
    AnimalParseSupport.parseAndSetDepth(stok, pt, localType);

    // specific settings - not available for all(sub)types!
    pt.setFWArrow(ParseSupport.parseOptionalWord(stok, localType + " fw arrow",
        "fwArrow"));
    pt.setBWArrow(ParseSupport.parseOptionalWord(stok, localType + " bw arrow",
        "bwArrow"));

    // add the object to the list of graphic objects
    BasicParser.addGraphicObject(pt, anim);

    // append the object id to the list
    oids.append(pt.getNum(false));

    // insert into object list -- necessary for lookups later on!
    getObjectIDs().put(s, pt.getNum(false));
    getObjectTypes().put(s, getTypeIdentifier("polyline"));

    AnimalParseSupport.showComponents(stok, "" + oids.toString(), localType,
        true);
  }

  /**
   * Create a PTPolyline from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parsePolygonInput() throws IOException {
    int i = 1, nodeCounter = 0;
    PTPoint node1, node2, node3;
    Point currentNode = null;
    PTPolygon pt = new PTPolygon();
    StringBuilder oids = new StringBuilder();

    // read in object type
    String localType = ParseSupport.parseWord(stok, "Polygon type")
        .toLowerCase();

    // read in OID(object name)
    String s = AnimalParseSupport.parseText(stok, "Polygon object name");

    // parse location specification
    currentNode = AnimalParseSupport.parseNodeInfo(stok, localType + "node 1",
        null);
    node1 = new PTPoint(currentNode);
    pt.setNode(nodeCounter++, node1);

    // read second node
    currentNode = AnimalParseSupport.parseNodeInfo(stok, localType + "node 2",
        null);
    node2 = new PTPoint(currentNode);
    i++;

    pt.setNode(nodeCounter++, node2); // add this node!

    // do we have another node...?
    if (ParseSupport.nextTokenIsNodeToken(stok)) {

      currentNode = AnimalParseSupport.parseNodeInfo(stok, localType + "node 3",
          null);
      node3 = new PTPoint(currentNode);
      i++;
      pt.setNode(nodeCounter++, node3);
      // if not triangle, continue till no more nodes are left.
      if (!localType.equalsIgnoreCase("triangle")) {
        while (ParseSupport.nextTokenIsNodeToken(stok)) {
          i++;
          currentNode = AnimalParseSupport.parseNodeInfo(stok,
              localType + "node " + i, null);
          pt.setNode(nodeCounter++, new PTPoint(currentNode));
        }
      }
    } // check for additional nodes finished
    else {
      stok.pushBack(); // push back component(NOT node paren)
    }

    pt.setObjectName(s);

    // parse and set the color
    pt.setColor(AnimalParseSupport.parseAndSetColor(stok, localType, "color"));

    // check for depth information and set it, if available
    AnimalParseSupport.parseAndSetDepth(stok, pt, localType);

    // specific settings - not available for all(sub)types!
    pt.setFilled(
        ParseSupport.parseOptionalWord(stok, localType + " filled", "filled"));

    if (pt.isFilled())
      pt.setFillColor(
          AnimalParseSupport.parseAndSetColor(stok, localType, "fillColor"));
    // add the object to the list of graphic objects
    BasicParser.addGraphicObject(pt, anim);

    // append the object id to the list
    oids.append(pt.getNum(false));

    // insert into object list -- necessary for lookups later on!
    getObjectIDs().put(s, pt.getNum(false));
    getObjectTypes().put(s, getTypeIdentifier("polyline"));
    // display the component, unless marked as 'hidden'
    AnimalParseSupport.showComponents(stok, "" + oids.toString(), localType,
        true);
  }

  /**
   * Create a PTPolyline from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parseRectangleInput() throws IOException {
    Point firstNode = null, secondNode = null;

    // read in object type
    String localType = ParseSupport.parseWord(stok, "Rectangle type")
        .toLowerCase();

    // read in OID(object name)
    String s = AnimalParseSupport.parseText(stok, "Rectangle object name");

    // parse location specification
    firstNode = AnimalParseSupport.parseNodeInfo(stok, localType + "node 1",
        null);
    // read second node
    secondNode = AnimalParseSupport.parseNodeInfo(stok, localType + "node 2",
        null);

    if (localType.equalsIgnoreCase("relrect")
        || localType.equalsIgnoreCase("relrectangle"))
      secondNode.translate(firstNode.x, firstNode.y);

    PTRectangle rectangle = new PTRectangle(firstNode, secondNode);
    rectangle.setObjectName(s);

    finishPolygonParsing(rectangle, localType);
  }

  /**
   * Create a PTPolyline from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parseTriangleInput() throws IOException {
    Point node1, node2, node3;

    // read in object type
    String localType = ParseSupport.parseWord(stok, "Triangle type")
        .toLowerCase();

    // read in OID(object name)
    String s = AnimalParseSupport.parseText(stok, "Triangle object name");

    // parse location specification
    node1 = AnimalParseSupport.parseNodeInfo(stok, localType + "node 1", null);

    // read second node
    node2 = AnimalParseSupport.parseNodeInfo(stok, localType + "node 2", null);

    node3 = AnimalParseSupport.parseNodeInfo(stok, localType + "node 3", null);

    PTTriangle triangle = new PTTriangle(node1, node2, node3);
    triangle.setObjectName(s);
    finishPolygonParsing(triangle, localType);
  }

  private void finishPolygonParsing(PolygonalShape shape, String localType)
      throws IOException {
    // parse and set the color
    shape.setColor(
        AnimalParseSupport.parseAndSetColor(stok, localType, "color"));

    // check for depth information and set it, if available
    AnimalParseSupport.parseAndSetDepth(stok, shape, localType);

    shape.setFilled(
        ParseSupport.parseOptionalWord(stok, localType + " filled", "filled"));

    if (shape.isFilled())
      shape.setFillColor(
          AnimalParseSupport.parseAndSetColor(stok, localType, "fillColor"));

    // add the object to the list of graphic objects
    BasicParser.addGraphicObject(shape, anim);

    // append the object id to the list
    StringBuilder oids = new StringBuilder();
    oids.append(shape.getNum(false));

    // insert into object list -- necessary for lookups later on!
    getObjectIDs().put(shape.getObjectName(), shape.getNum(false));
    getObjectTypes().put(shape.getObjectName(), getTypeIdentifier("triangle"));
    // display the component, unless marked as 'hidden'
    AnimalParseSupport.showComponents(stok, "" + oids.toString(), localType,
        true);
  }

  /**
   * Create a PTPolyline from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parseSquareInput() throws IOException {
    Point currentNode = null;

    // read in object type
    String localType = ParseSupport.parseWord(stok, "Square type")
        .toLowerCase();

    // read in OID(object name)
    String s = AnimalParseSupport.parseText(stok, "Square object name");

    // parse location specification
    currentNode = AnimalParseSupport.parseNodeInfo(stok, localType + "node",
        null);
    // square: read only one node
    int sideLength = ParseSupport.parseInt(stok, localType + " side length");

    // fix length: width == offset means(x, x+width-1)
    sideLength--;
    PTSquare square = new PTSquare(currentNode.x, currentNode.y, sideLength);
    square.setObjectName(s);
    finishPolygonParsing(square, localType);
  }

  /**
   * Create a PTText from the description read from the StreamTokenizer. The
   * description is usually generated by other programs and dumped in a file or
   * on System.out.
   */
  public void parseTextInput() throws IOException {
    // String colorName, fontName = "Serif";
    // int fontStyle = 0, fontSize = 16;
    // int token = 0;
    // boolean bold = false, italic = false,
    boolean isCentered = false, isRightAligned = false;
    PTText pt = new PTText();
    StringBuilder oids = new StringBuilder();

    // check for type information
    ParseSupport.parseMandatoryWord(stok, "Text type", "text");

    // read in OID(object name)
    String s = AnimalParseSupport.parseText(stok, "Text object name");
    pt.setObjectName(s);

    // parse the text component
    pt.setText(AnimalParseSupport.parseText(stok, "Text component", "text",
        false, chosenLanguage));
    // parse location specification
    ParseSupport.parseOptionalWord(stok, "Text command 'at'(deprecated)", "at");
    Point basePoint = AnimalParseSupport.parseNodeInfo(stok, "text baseline",
        null);

    // set the location
//    pt.setLocation(basePoint);
    getObjectProperties().put(s + ".baseline", basePoint);
    // check if centered horizontally
    isCentered = ParseSupport.parseOptionalWord(stok, "'centered' tag for Text",
        "centered");
    if (!isCentered)
      isRightAligned = ParseSupport.parseOptionalWord(stok,
          "'right' tag for Text", "right");

    // parse and set the color
    pt.setColor(AnimalParseSupport.parseAndSetColor(stok, "text", "color"));

    // check for depth information and set it, if available
    AnimalParseSupport.parseAndSetDepth(stok, pt, "text");

    // set the font
    Font f = AnimalParseSupport.parseFontInfo(stok, "text");
    getObjectProperties().put(s + ".font", f);
    pt.setFont(f);
    // set the location AFTER the font has been resolved....
    pt.setLocation(basePoint);
    if (basePoint.x != pt.getLocation().getX() || basePoint.y != pt.getLocation().getY())
      System.err.println("MismatchB:" +basePoint +" ... " +pt);
    // MessageDisplay.addDebugMessage("PT " + pt.getObjectName() +" location: "
    // +pt.getLocation()
    // +" bb: " +pt.getBoundingBox() +" entry: " +pt.getText());

    // if object is centered, figure out translation
    if (isCentered || isRightAligned) {
      FontMetrics fm = Animal.getConcreteFontMetrics(f);
      // Toolkit.getDefaultToolkit().getFontMetrics(f);
      int translationWidth = fm.stringWidth(pt.getText());
      if (isCentered)
        pt.translate(-(translationWidth >>> 1), 0);
      else if (isRightAligned)
        pt.translate(-translationWidth, 0);
    }
    if (!isCentered && !isRightAligned && 
        (basePoint.x != pt.getLocation().getX() || basePoint.y != pt.getLocation().getY()))
      System.err.println("MismatchC:" +basePoint +" ... " +pt);
    // MessageDisplay.addDebugMessage("PT2 location: " +pt.getLocation() +" bb:
    // " +pt.getBoundingBox() +" entry: " +pt.getText());
    // add the object to the list of graphic objects
    BasicParser.addGraphicObject(pt, anim);
//System.err.println(pt);
    // append object ID to list
    oids.append(pt.getNum(false));
    // MessageDisplay.addDebugMessage("PT3 location: " +pt.getLocation() +" bb:
    // " +pt.getBoundingBox() +" entry: " +pt.getText());

    if (ParseSupport.parseOptionalWord(stok, "'boxed' tag for text", "boxed")) {
      Rectangle bBox = pt.getBoundingBox();
      int offsetX = 3, offsetY = 3;
      int[] xNodes = new int[] { bBox.x - offsetX,
          bBox.x + bBox.width + offsetX, bBox.x + bBox.width + offsetX,
          bBox.x - offsetX };
      int[] yNodes = new int[] { bBox.y - offsetY, bBox.y - offsetY,
          bBox.y + bBox.height + offsetY, bBox.y + bBox.height + offsetY };

      PTPolygon textBox = new PTPolygon(xNodes, yNodes);
      if (pt.getDepth() == Integer.MAX_VALUE)
        pt.setDepth(Integer.MAX_VALUE - 1);
      textBox.setDepth(pt.getDepth() + 1);
      // textBox.setClosed(true);
      textBox.setFilled(true);
      textBox.setColor(Color.black);
      textBox.setFillColor(AnimalParseSupport.parseAndSetColor(stok, "text box",
          "fillColor", "white"));
      textBox.setObjectName(pt.getObjectName() + ".box");
      BasicParser.addGraphicObject(textBox, anim);
      getObjectTypes().put(s + ".box", getTypeIdentifier("polyline"));
      oids.append(" ").append(textBox.getNum(false));
    }

    // insert into object list -- necessary for lookups later on!
    getObjectIDs().put(s, oids.toString());
    getObjectTypes().put(s, getTypeIdentifier("text"));

    // display the component, unless marked as 'hidden'
    AnimalParseSupport.showComponents(stok, oids.toString(), "text", true);
    // MessageDisplay.addDebugMessage("object is now at " +pt.getBoundingBox());
    if (!isCentered && !isRightAligned && 
        (basePoint.x != pt.getLocation().getX() || basePoint.y != pt.getLocation().getY()))
      System.err.println("MismatchD:" +basePoint +" ... " +pt);
  }

  public void chooseLanguage() {
    chosenLanguage = (String) JOptionPane.showInputDialog(null,
        "Choose a language", "Language Choice", JOptionPane.QUESTION_MESSAGE,
        null, registeredLanguages, registeredLanguages[0]);
    if (chosenLanguage == null)
      chosenLanguage = registeredLanguages[0];
  }
}
