package algoanim.primitives;

import java.awt.Color;
import java.util.HashMap;
import java.util.LinkedList;

import algoanim.primitives.generators.GraphGenerator;
import algoanim.properties.AnimationPropertiesKeys;
import algoanim.properties.GraphProperties;
import algoanim.util.Coordinates;
import algoanim.util.DisplayOptions;
import algoanim.util.Node;
import algoanim.util.Timing;
import autoGraph.EdgeComp;
import autoGraph.GraphComp;
import autoGraph.NodeComp;

/**
 * Represents a graph
 * 
 * @author Dr. Guido Roessling (roessling@acm.org>
 * @version 0.7 2007-04-04
 * 
 *          edited to support automatic graph drawing by Marian Hieke 2018-05-24
 */
public class Graph extends Primitive {
	private GraphGenerator generator = null;

	// private String text = null;

	protected String[] nodeLabels = null;

	protected Node[] nodes = null;

	protected int[][] adjacencyMatrix = null;

	private GraphProperties properties = null;

	private GraphComp graphComp;

	private NodeComp start;

	private NodeComp target;

	private int defaultRadius = 20;

	private int defaultIterations = 150;

	private int defaultPostIterations = 4;

	private LinkedList<Coordinates> locations = new LinkedList<Coordinates>();

	private HashMap<Node, Node> oldNew;

	private boolean autogenerated = false;

	// Madi
	private Node startNode;
	private Node targetNode;

	private HashMap<Integer, Node> mapI2N = null;
	private HashMap<Node, Integer> mapN2I = null;

	public Graph(GraphGenerator graphGen, Graph oldGraph, DisplayOptions display, GraphProperties props) {
		super(graphGen, display);
		adjacencyMatrix = oldGraph.adjacencyMatrix;
		generator = graphGen;
		nodeLabels = oldGraph.nodeLabels;
		nodes = oldGraph.nodes;
		properties = props;
		startNode = oldGraph.startNode;
		targetNode = oldGraph.targetNode;

		setName(oldGraph.getName());
		generator.create(this);
		mapI2N = new HashMap<Integer, Node>(adjacencyMatrix.length * adjacencyMatrix[0].length + 13);
		int pos = 0;
		for (Node node : nodes) {
			mapI2N.put(Integer.valueOf(pos++), node);
		}
		mapN2I = new HashMap<Node, Integer>(adjacencyMatrix.length * adjacencyMatrix[0].length + 13);
		pos = 0;
		for (Node node : nodes) {
			mapN2I.put(node, Integer.valueOf(pos++));
		}
	}

	/**
	 * Instantiates the <code>Graph</code> and calls the create() method of the
	 * associated <code>GraphGenerator</code>.
	 * 
	 * @param graphGen
	 *            the appropriate code <code>Generator</code>.
	 * @param name
	 *            the name for the graph
	 * @param graphAdjacencyMatrix
	 *            the adjacency matrix for the graph
	 * @param graphNodes
	 *            the graph's nodes
	 * @param labels
	 *            the labels for the graph nodes
	 * @param display
	 *            [optional] the <code>DisplayOptions</code> of this
	 *            <code>Text</code> element.
	 * @param props
	 *            [optional] the properties of this <code>Text</code> element.
	 */
	public Graph(GraphGenerator graphGen, String name, int[][] graphAdjacencyMatrix, Node[] graphNodes, String[] labels,
			DisplayOptions display, GraphProperties props) {
		super(graphGen, display);

		generator = graphGen;
		properties = props;
		setName(name);
		if (graphAdjacencyMatrix == null || graphNodes == null || graphAdjacencyMatrix.length != graphNodes.length)
			throw new IllegalArgumentException("Adjacency matrix and nodes must not be empty and have same size!");
		adjacencyMatrix = graphAdjacencyMatrix;
		nodes = graphNodes;
		nodeLabels = labels;
		generator.create(this);
		mapI2N = new HashMap<Integer, Node>(adjacencyMatrix.length * adjacencyMatrix[0].length + 13);
		int pos = 0;
		for (Node node : nodes) {
			mapI2N.put(Integer.valueOf(pos++), node);
		}
		mapN2I = new HashMap<Node, Integer>(adjacencyMatrix.length * adjacencyMatrix[0].length + 13);
		pos = 0;
		for (Node node : nodes) {
			mapN2I.put(node, Integer.valueOf(pos++));
		}
	}

	/**
	 * Autodraw without given nodes
	 * --------------------------------------------------------------------------------------------------
	 * 
	 * 
	 */

	/**
	 * * Instantiates the <code>Graph</code> and calls the create() method of the
	 * associated <code>GraphGenerator</code>. Uses the autodraw function to place
	 * the nodes of the graph without the need to specify there position.
	 * 
	 * @param graphGen
	 *            the appropriate code <code>Generator</code>.
	 * @param name
	 *            name the name for the graph
	 * @param graphAdjacencyMatrix
	 *            graphAdjacencyMatrix the adjacency matrix for the graph
	 * @param labels
	 *            labels the labels for the graph nodes
	 * @param display
	 *            display [optional] the <code>DisplayOptions</code> of this
	 *            <code>Text</code> element.
	 * @param props
	 *            props [optional] the properties of this <code>Text</code> element.
	 * @param xUpperLeft
	 *            the upper left x coordinate of the area for drawing the graph in
	 * @param yUpperLeft
	 *            the upper left y coordinate of the area for drawing the graph in
	 * @param xLowerRight
	 *            the lower right x coordinate of the area for drawing the graph in
	 * @param yLowerRight
	 *            the lower right y coordinate of the area for drawing the graph in
	 * @param minEdgeLength
	 *            the minimum edge length between two nodes
	 * @param nodeRadius
	 *            the radius of the nodes
	 * @param loopIterations
	 *            the iterations of the force directed node placement
	 * @param postIterations
	 *            the iterations for reducing crossing edge
	 * @param raster
	 *            specifies if nodes with similar x or y coordinate get the same x
	 *            or y coordinate
	 * @param xEpsilon
	 *            the x epsilon in which two nodes get the same x coordinate
	 * @param yEpsilon
	 *            the y epsilon in which two nodes get the same y coordinate
	 */
	public Graph(GraphGenerator graphGen, String name, int[][] graphAdjacencyMatrix, String[] labels,
			DisplayOptions display, GraphProperties props, int xUpperLeft, int yUpperLeft, int xLowerRight,
			int yLowerRight, int minEdgeLength, int nodeRadius, int loopIterations, int postIterations, boolean raster,
			int xEpsilon, int yEpsilon) {
		super(graphGen, display);

		graphComp = new GraphComp();
		generator = graphGen;
		properties = props;


		if (nodeRadius >= 0) {
			this.defaultRadius = nodeRadius;
		}

		if (labels == null) {
			System.out.println("new graph without labels for generating nodes");
		}

		setName(name);
		if (graphAdjacencyMatrix == null || labels == null || graphAdjacencyMatrix.length != labels.length)
			throw new IllegalArgumentException("Adjacency matrix and labels must not be empty and have same size!");
		adjacencyMatrix = graphAdjacencyMatrix;
		nodes = new Node[labels.length];
		nodeLabels = labels;

		// add the nodes of the graoh to the graphComp
		NodeComp nodeComp;
		int idCounter = 0;
		for (Node node : nodes) {
			nodeComp = new NodeComp(defaultRadius, idCounter);
			graphComp.addNode(nodeComp);
			idCounter++;
		}

		// adding the edges

		boolean found = false;
		for (int i = 0; i < graphAdjacencyMatrix.length; i++) {
			for (int j = 0; j < graphAdjacencyMatrix[i].length; j++) {

				for (EdgeComp e : graphComp.getAllEdges()) {
					if ((e.getNodeA().getId() == i && e.getNodeB().getId() == j)
							|| (e.getNodeA().getId() == j && e.getNodeB().getId() == i) || (i == j)) {
						found = true;
					}
				}
				if (!found) {
					if (graphAdjacencyMatrix[i][j] != 0) {
						graphComp.addEdge(graphComp.getNodeForId(i), graphComp.getNodeForId(j));
					}
				} else {
					found = false;
				}
			}
		}

		if (minEdgeLength >= 0) {
			graphComp.setMinEdgeLEngth(minEdgeLength);
			graphComp.setDesiredEdgeLength(minEdgeLength);
		} else {
			graphComp.setMinEdgeLEngth(2 * defaultRadius);
			graphComp.setDesiredEdgeLength(2 * defaultRadius);
		}

		int xMax = 400;
		int yMax = 400;

		if (xLowerRight - xUpperLeft >= 0) {
			xMax = xLowerRight - xUpperLeft;
		}

		if (yLowerRight - yUpperLeft >= 0) {
			yMax = yLowerRight - yUpperLeft;
		}

		if (xEpsilon < 0)
			xEpsilon = 0;

		if (yEpsilon < 0)
			yEpsilon = 0;

		if (loopIterations >= 0)
			defaultIterations = loopIterations;

		if (postIterations >= 0)
			defaultPostIterations = postIterations;

		graphComp.setHeightMax(yMax);
		graphComp.setWidthMax(xMax);
		graphComp.setRadiusForNode(defaultRadius);
		graphComp.setIterations(defaultIterations);
		graphComp.setPostProcessIt(defaultPostIterations);
		graphComp.setTemperature(graphComp.getWidthMax() * 10);
		graphComp.setRaster(raster);
		graphComp.setXEpsilon(xEpsilon);
		graphComp.setYEpsilon(yEpsilon);
		graphComp.placeNodesForceDirected();
		LinkedList<NodeComp> nodeComps = graphComp.getAllNodes();
		Coordinates location;
		int offsetX = ((defaultRadius / 2) + xUpperLeft + (xMax / 2));
		int offsetY = ((defaultRadius / 2) + yUpperLeft + (yMax / 2));
		int x = 0;
		int y = 0;
		for (NodeComp n : nodeComps) {

			x = ((int) n.getPosition().getX() + offsetX > xUpperLeft) ? (int) n.getPosition().getX() + offsetX
					: xUpperLeft;
			x = ((int) n.getPosition().getX() + offsetX < xLowerRight) ? (int) n.getPosition().getX() + offsetX
					: xLowerRight;
			y = ((int) n.getPosition().getY() + offsetY > yUpperLeft) ? (int) n.getPosition().getY() + offsetY
					: yUpperLeft;
			y = ((int) n.getPosition().getY() + offsetY < yLowerRight) ? (int) n.getPosition().getY() + offsetY
					: yLowerRight;
			location = new Coordinates(x, y);
			locations.add(location);
		}

		for (int i = 0; i < nodes.length; i++) {
			nodes[i] = locations.get(i);
		}

		generator.create(this);
		mapI2N = new HashMap<Integer, Node>(adjacencyMatrix.length * adjacencyMatrix[0].length + 13);
		int pos = 0;
		for (Node node : nodes) {
			mapI2N.put(Integer.valueOf(pos++), node);
		}
		mapN2I = new HashMap<Node, Integer>(adjacencyMatrix.length * adjacencyMatrix[0].length + 13);
		pos = 0;
		for (Node node : nodes) {
			mapN2I.put(node, Integer.valueOf(pos++));
		}



	}

	/**
	 * * Instantiates the <code>Graph</code> and calls the create() method of the
	 * associated <code>GraphGenerator</code>. Uses the autodraw function to places
	 * the nodes of the graph without the need to specify there position.
	 * 
	 * @param graphGen
	 *            the appropriate code <code>Generator</code>.
	 * @param name
	 *            name the name for the graph
	 * @param graphAdjacencyMatrix
	 *            graphAdjacencyMatrix the adjacency matrix for the graph
	 * @param labels
	 *            labels the labels for the graph nodes
	 * @param display
	 *            display [optional] the <code>DisplayOptions</code> of this
	 *            <code>Text</code> element.
	 * @param props
	 *            props [optional] the properties of this <code>Text</code> element.
	 * @param xUpperLeft
	 *            the upper left x coordinate of the area for drawing the graph in
	 * @param yUpperLeft
	 *            the upper left y coordinate of the area for drawing the graph in
	 * @param xLowerRight
	 *            the lower right x coordinate of the area for drawing the graph in
	 * @param yLowerRight
	 *            the lower right y coordinate of the area for drawing the graph in
	 * @param raster
	 *            specifies if nodes with similar x or y coordinate get the same x
	 *            or y coordinate
	 * @param xEpsilon
	 *            the x epsilon in which two nodes get the same x coordinate
	 * @param yEpsilon
	 *            the y epsilon in which two nodes get the same y coordinate
	 */
	public Graph(GraphGenerator graphGen, String name, int[][] graphAdjacencyMatrix, String[] labels,
			DisplayOptions display, GraphProperties props, int xUpperLeft, int yUpperLeft, int xLowerRight,
			int yLowerRight, boolean raster, int xEpsilon, int yEpsilon) {

		this(graphGen, name, graphAdjacencyMatrix, labels, display, props, xUpperLeft, yUpperLeft, xLowerRight,
				yLowerRight, 2 * 20, 20, 150, 4, raster, xEpsilon, yEpsilon);

	}

	/**
	 * * Instantiates the <code>Graph</code> and calls the create() method of the
	 * associated <code>GraphGenerator</code>. Uses the autodraw function to place
	 * the nodes of the graph without the need to specify there position.
	 * 
	 * @param graphGen
	 *            the appropriate code <code>Generator</code>.
	 * @param name
	 *            name the name for the graph
	 * @param graphAdjacencyMatrix
	 *            graphAdjacencyMatrix the adjacency matrix for the graph
	 * @param labels
	 *            labels the labels for the graph nodes
	 * @param display
	 *            display [optional] the <code>DisplayOptions</code> of this
	 *            <code>Text</code> element.
	 * @param props
	 *            props [optional] the properties of this <code>Text</code> element.
	 * @param xUpperLeft
	 *            the upper left x coordinate of the area for drawing the graph in
	 * @param yUpperLeft
	 *            the upper left y coordinate of the area for drawing the graph in
	 * @param xLowerRight
	 *            the lower right x coordinate of the area for drawing the graph in
	 * @param yLowerRight
	 *            the lower right y coordinate of the area for drawing the graph in
	 */
	public Graph(GraphGenerator graphGen, String name, int[][] graphAdjacencyMatrix, String[] labels,
			DisplayOptions display, GraphProperties props, int xUpperLeft, int yUpperLeft, int xLowerRight,
			int yLowerRight) {
		this(graphGen, name, graphAdjacencyMatrix, labels, display, props, xUpperLeft, yUpperLeft, xLowerRight,
				yLowerRight, 2 * 20, 20, 150, 4, false, 0, 0);
	}

	/**
	 * * Instantiates the <code>Graph</code> and calls the create() method of the
	 * associated <code>GraphGenerator</code>. Uses the autodraw function to place
	 * the nodes of the graph without the need to specify there position.
	 * 
	 * @param graphGen
	 *            the appropriate code <code>Generator</code>.
	 * @param name
	 *            name the name for the graph
	 * @param graphAdjacencyMatrix
	 *            graphAdjacencyMatrix the adjacency matrix for the graph
	 * @param labels
	 *            labels the labels for the graph nodes
	 * @param xUpperLeft
	 *            the upper left x coordinate of the area for drawing the graph in
	 * @param yUpperLeft
	 *            the upper left y coordinate of the area for drawing the graph in
	 * @param xLowerRight
	 *            the lower right x coordinate of the area for drawing the graph in
	 * @param yLowerRight
	 *            the lower right y coordinate of the area for drawing the graph in
	 */
	public Graph(GraphGenerator graphGen, String name, int[][] graphAdjacencyMatrix, String[] labels, int xUpperLeft,
			int yUpperLeft, int xLowerRight, int yLowerRight) {

		this(graphGen, name, graphAdjacencyMatrix, labels, null, new GraphProperties(), xUpperLeft, yUpperLeft,
				xLowerRight, yLowerRight, 2 * 20, 20, 150, 4, false, 0, 0);
	}

	/**
	 * ________________________________________________________AutoGraph____________________________________________________________________________________
	 * 
	 * 
	 * /** * Instantiates the <code>Graph</code> and calls the create() method of
	 * the associated <code>GraphGenerator</code>. Uses the autodraw function to
	 * place the nodes of the graph without the need to specify there position.
	 * 
	 * @param graphGen
	 *            the appropriate code <code>Generator</code>.
	 * @param name
	 *            name the name for the graph
	 * @param graphAdjacencyMatrix
	 *            graphAdjacencyMatrix the adjacency matrix for the graph
	 * @param graphNodes
	 *            graphNodes the graph's nodes
	 * @param labels
	 *            labels the labels for the graph nodes
	 * @param display
	 *            display [optional] the <code>DisplayOptions</code> of this
	 *            <code>Text</code> element.
	 * @param props
	 *            props [optional] the properties of this <code>Text</code> element.
	 * @param xUpperLeft
	 *            the upper left x coordinate of the area for drawing the graph in
	 * @param yUpperLeft
	 *            the upper left y coordinate of the area for drawing the graph in
	 * @param xLowerRight
	 *            the lower right x coordinate of the area for drawing the graph in
	 * @param yLowerRight
	 *            the lower right y coordinate of the area for drawing the graph in
	 * @param minEdgeLength
	 *            the minimum edge length between two nodes
	 * @param nodeRadius
	 *            the radius of the nodes
	 * @param loopIterations
	 *            the iterations of the force directed node placement
	 * @param postIterations
	 *            the iterations for reducing crossing edge
	 * @param raster
	 *            specifies if nodes with similar x or y coordinate get the same x
	 *            or y coordinate
	 * @param xEpsilon
	 *            the x epsilon in which two nodes get the same x coordinate
	 * @param yEpsilon
	 *            the y epsilon in which two nodes get the same y coordinate
	 */
	public Graph(GraphGenerator graphGen, String name, int[][] graphAdjacencyMatrix, Node[] graphNodes, String[] labels,
			DisplayOptions display, GraphProperties props, int xUpperLeft, int yUpperLeft, int xLowerRight,
			int yLowerRight, int minEdgeLength, int nodeRadius, int loopIterations, int postIterations, boolean raster,
			int xEpsilon, int yEpsilon) {
		super(graphGen, display);
		this.autogenerated = true;

		graphComp = new GraphComp();
		generator = graphGen;
		properties = props;
		Node[] oldNodes = graphNodes;

		if (nodeRadius >= 0) {
			this.defaultRadius = nodeRadius;
		}

		if (graphNodes == null) {
			System.out.println("new graph without nodes");
		}

		setName(name);
		if (graphAdjacencyMatrix == null || graphNodes == null || graphAdjacencyMatrix.length != graphNodes.length)
			throw new IllegalArgumentException("Adjacency matrix and nodes must not be empty and have same size!");
		adjacencyMatrix = graphAdjacencyMatrix;
		nodes = graphNodes;
		nodeLabels = labels;

		// add the nodes of the graoh to the graphComp
		NodeComp nodeComp;
		int idCounter = 0;
		for (Node node : nodes) {
			nodeComp = new NodeComp(defaultRadius, idCounter);
			graphComp.addNode(nodeComp);
			idCounter++;
		}

		// adding the edges

		boolean found = false;
		for (int i = 0; i < graphAdjacencyMatrix.length; i++) {
			for (int j = 0; j < graphAdjacencyMatrix[i].length; j++) {

				for (EdgeComp e : graphComp.getAllEdges()) {
					if ((e.getNodeA().getId() == i && e.getNodeB().getId() == j)
							|| (e.getNodeA().getId() == j && e.getNodeB().getId() == i) || (i == j)) {
						found = true;
					}
				}
				if (!found) {
					if (graphAdjacencyMatrix[i][j] != 0) {
						graphComp.addEdge(graphComp.getNodeForId(i), graphComp.getNodeForId(j));
					}
				} else {
					found = false;
				}
			}
		}

		if (minEdgeLength >= 0) {
			graphComp.setMinEdgeLEngth(minEdgeLength);
			graphComp.setDesiredEdgeLength(minEdgeLength);
		} else {
			graphComp.setMinEdgeLEngth(2 * defaultRadius);
			graphComp.setDesiredEdgeLength(2 * defaultRadius);
		}

		int xMax = 400;
		int yMax = 400;

		if (xLowerRight - xUpperLeft >= 0) {
			xMax = xLowerRight - xUpperLeft;
		}

		if (yLowerRight - yUpperLeft >= 0) {
			yMax = yLowerRight - yUpperLeft;
		}

		if (xEpsilon < 0)
			xEpsilon = 0;

		if (yEpsilon < 0)
			yEpsilon = 0;

		if (loopIterations >= 0)
			defaultIterations = loopIterations;

		if (postIterations >= 0)
			defaultPostIterations = postIterations;

		graphComp.setHeightMax(yMax);
		graphComp.setWidthMax(xMax);
		graphComp.setRadiusForNode(defaultRadius);
		graphComp.setIterations(defaultIterations);
		graphComp.setPostProcessIt(defaultPostIterations);
		graphComp.setTemperature(graphComp.getWidthMax() * 10);
		graphComp.setRaster(raster);
		graphComp.setXEpsilon(xEpsilon);
		graphComp.setYEpsilon(yEpsilon);
		graphComp.placeNodesForceDirected();
		LinkedList<NodeComp> nodeComps = graphComp.getAllNodes();
		Coordinates location;
		int offsetX = ((defaultRadius / 2) + xUpperLeft + (xMax / 2));
		int offsetY = ((defaultRadius / 2) + yUpperLeft + (yMax / 2));
		int x = 0;
		int y = 0;
		for (NodeComp n : nodeComps) {

			x = ((int) n.getPosition().getX() + offsetX > xUpperLeft) ? (int) n.getPosition().getX() + offsetX
					: xUpperLeft;
			x = ((int) n.getPosition().getX() + offsetX < xLowerRight) ? (int) n.getPosition().getX() + offsetX
					: xLowerRight;
			y = ((int) n.getPosition().getY() + offsetY > yUpperLeft) ? (int) n.getPosition().getY() + offsetY
					: yUpperLeft;
			y = ((int) n.getPosition().getY() + offsetY < yLowerRight) ? (int) n.getPosition().getY() + offsetY
					: yLowerRight;
			location = new Coordinates(x, y);
			locations.add(location);
		}

		for (int i = 0; i < nodes.length; i++) {
			nodes[i] = locations.get(i);
		}

		generator.create(this);
		mapI2N = new HashMap<Integer, Node>(adjacencyMatrix.length * adjacencyMatrix[0].length + 13);
		int pos = 0;
		for (Node node : nodes) {
			mapI2N.put(Integer.valueOf(pos++), node);
		}
		mapN2I = new HashMap<Node, Integer>(adjacencyMatrix.length * adjacencyMatrix[0].length + 13);
		pos = 0;
		for (Node node : nodes) {
			mapN2I.put(node, Integer.valueOf(pos++));
		}

		oldNew = new HashMap<Node, Node>(oldNodes.length);

		for (int i = 0; i < oldNodes.length; i++) {
			oldNew.put(oldNodes[i], nodes[i]);
		}

	}



	/**
	 * Instantiates the <code>Graph</code> and calls the create() method of the
	 * associated <code>GraphGenerator</code>. Uses the autodraw function to place
	 * the nodes of the graph without the need to specify there position. Version
	 * with default minimal edge length, node radius and loop iterations
	 * 
	 * @param graphGen
	 *            the appropriate code <code>Generator</code>.
	 * @param name
	 *            name the name for the graph
	 * @param graphAdjacencyMatrix
	 *            graphAdjacencyMatrix the adjacency matrix for the graph
	 * @param graphNodes
	 *            graphNodes the graph's nodes
	 * @param labels
	 *            labels the labels for the graph nodes
	 * @param display
	 *            display [optional] the <code>DisplayOptions</code> of this
	 *            <code>Text</code> element.
	 * @param props
	 *            props [optional] the properties of this <code>Text</code> element.
	 * @param xUpperLeft
	 *            the upper left x coordinate of the area for drawing the graph in
	 * @param yUpperLeft
	 *            the upper left y coordinate of the area for drawing the graph in
	 * @param xLowerRight
	 *            the lower right x coordinate of the area for drawing the graph in
	 * @param yLowerRight
	 *            the lower right y coordinate of the area for drawing the graph in
	 * @param raster
	 *            specifies if nodes with similar x or y coordinate get the same x
	 *            or y coordinate
	 * @param xEpsilon
	 *            the x epsilon in which two nodes get the same x coordinate
	 * @param yEpsilon
	 *            the y epsilon in which two nodes get the same y coordinate
	 */
	public Graph(GraphGenerator graphGen, String name, int[][] graphAdjacencyMatrix, Node[] graphNodes, String[] labels,
			DisplayOptions display, GraphProperties props, int xUpperLeft, int yUpperLeft, int xLowerRight,
			int yLowerRight, boolean raster, int xEpsilon, int yEpsilon) {
		this(graphGen, name, graphAdjacencyMatrix, graphNodes, labels, display, props, xUpperLeft, yUpperLeft,
				xLowerRight, yLowerRight, 2 * 20, 20, 150, 4, raster, xEpsilon, yEpsilon);
	}

	/**
	 * Instantiates the <code>Graph</code> and calls the create() method of the
	 * associated <code>GraphGenerator</code>. Uses the autodraw function to place
	 * the nodes of the graph without the need to specify there position. Version
	 * with default minimal edge length, node radius and loop iterations
	 * 
	 * @param graphGen
	 *            the appropriate code <code>Generator</code>.
	 * @param name
	 *            name the name for the graph
	 * @param graphAdjacencyMatrix
	 *            graphAdjacencyMatrix the adjacency matrix for the graph
	 * @param graphNodes
	 *            graphNodes the graph's nodes
	 * @param labels
	 *            labels the labels for the graph nodes
	 * @param display
	 *            display [optional] the <code>DisplayOptions</code> of this
	 *            <code>Text</code> element.
	 * @param props
	 *            props [optional] the properties of this <code>Text</code> element.
	 * @param xUpperLeft
	 *            the upper left x coordinate of the area for drawing the graph in
	 * @param yUpperLeft
	 *            the upper left y coordinate of the area for drawing the graph in
	 * @param xLowerRight
	 *            the lower right x coordinate of the area for drawing the graph in
	 * @param yLowerRight
	 *            the lower right y coordinate of the area for drawing the graph in
	 * 
	 */
	public Graph(GraphGenerator graphGen, String name, int[][] graphAdjacencyMatrix, Node[] graphNodes, String[] labels,
			DisplayOptions display, GraphProperties props, int xUpperLeft, int yUpperLeft, int xLowerRight,
			int yLowerRight) {

		this(graphGen, name, graphAdjacencyMatrix, graphNodes, labels, display, props, xUpperLeft, yUpperLeft,
				xLowerRight, yLowerRight, 2 * 20, 20, 150, 4, false, 0, 0);

	}

	/**
	 * Instantiates the <code>Graph</code> and calls the create() method of the
	 * associated <code>GraphGenerator</code>. Uses the autodraw function to place
	 * the nodes of the graph without the need to specify there position. Version
	 * with default minimal edge length, node radius and loop iterations
	 * 
	 * @param graphGen
	 *            the appropriate code <code>Generator</code>.
	 * @param name
	 *            name the name for the graph
	 * @param graphAdjacencyMatrix
	 *            graphAdjacencyMatrix the adjacency matrix for the graph
	 * @param graphNodes
	 *            graphNodes the graph's nodes
	 * @param labels
	 *            labels the labels for the graph nodes
	 * @param xUpperLeft
	 *            the upper left x coordinate of the area for drawing the graph in
	 * @param yUpperLeft
	 *            the upper left y coordinate of the area for drawing the graph in
	 * @param xLowerRight
	 *            the lower right x coordinate of the area for drawing the graph in
	 * @param yLowerRight
	 *            the lower right y coordinate of the area for drawing the graph in
	 * 
	 */
	public Graph(GraphGenerator graphGen, String name, int[][] graphAdjacencyMatrix, Node[] graphNodes, String[] labels,
			int xUpperLeft, int yUpperLeft, int xLowerRight, int yLowerRight) {

		this(graphGen, name, graphAdjacencyMatrix, graphNodes, labels, null, new GraphProperties(), xUpperLeft,
				yUpperLeft, xLowerRight, yLowerRight, 2 * 20, 20, 150, 4, false, 0, 0);

	}

	/**
	 * Returns the properties of this <code>Graph</code> element.
	 * 
	 * @return the properties of this <code>Graph</code> element.
	 */
	public GraphProperties getProperties() {
		return properties;
	}

	public Node getNodeForIndex(int index) {
		if (index >= 0 && index < adjacencyMatrix.length)
			return mapI2N.get(Integer.valueOf(index));
		return null;
	}

	public int getPositionForNode(Node node) {
		if (node != null) {
			Integer i = mapN2I.get(node);
			if (i == null)
				return -1;
			return i.intValue();
		}
		return -1;
	}

	private boolean checkForValidIndex(int row, int col, String methodName) {
		if (adjacencyMatrix != null && row >= 0 && row < adjacencyMatrix.length && col >= 0
				&& col < adjacencyMatrix[row].length)
			return true;
		throw new IllegalArgumentException(
				"Invalid access for method " + methodName + " to non-existent cell [" + row + "][" + col + "]");
	}

	/**
	 * Returns the adjacency matrix of this <code>Graph</code> element.
	 * 
	 * @return the adjaceny matrix of this <code>Graph</code> element.
	 */
	public int[][] getAdjacencyMatrix() {
		return adjacencyMatrix;
	}

	public void setAdjacencyMatrix(int[][] newMatrix) {
		if (newMatrix != null) {
			for (int i = 0; i < newMatrix.length; i++) {
				for (int j = 0; j < newMatrix[i].length; j++) {
					if (newMatrix[i][j] != 0) {
						setEdgeWeight(i, j, newMatrix[i][j], null, null);
					}
				}
			}
			adjacencyMatrix = newMatrix;
		}
	}

	public int getSize() {
		if (adjacencyMatrix != null)
			return adjacencyMatrix.length;
		return 0;
	}

	public Node[] getNodes() {
		return nodes;
	}

	public Node getNode(int nodeNr) {
		if (checkForValidIndex(nodeNr, nodeNr, "getNode"))
			return nodes[nodeNr];
		return null;
	}

	public String getNodeLabel(int nodeNr) {
		if (checkForValidIndex(nodeNr, nodeNr, "getNodeLabels"))
			return nodeLabels[nodeNr];
		return null;
	}

	public String getNodeLabel(Node node) {
		return getNodeLabel(getPositionForNode(node));
	}

	/**
	 * Returns the adjacency matrix of this <code>Graph</code> element.
	 * 
	 * @return the adjaceny matrix of this <code>Graph</code> element.
	 */
	public int[] getEdgesForNode(int node) {
		if (checkForValidIndex(node, 0, "getEdgesForNode"))
			return adjacencyMatrix[node];
		return null;
	}

	public int[] getEdgesForNode(Node node) {
		return getEdgesForNode(getPositionForNode(node));
	}

	public int getEdgeWeight(int fromNode, int toNode) {
		if (checkForValidIndex(fromNode, toNode, "getEdgeWeight"))
			return adjacencyMatrix[fromNode][toNode];
		return 0;
	}

	public int getEdgeWeight(Node from, Node to) {
		return getEdgeWeight(getPositionForNode(from), getPositionForNode(to));
	}

	public void setEdgeWeight(int fromNode, int toNode, int weight, Timing offset, Timing duration) {
		setEdgeWeight(fromNode, toNode, String.valueOf(weight), offset, duration);
		adjacencyMatrix[fromNode][toNode] = weight;
	}

	public void setEdgeWeight(Node from, Node to, int weight, Timing offset, Timing duration) {
		setEdgeWeight(getPositionForNode(from), getPositionForNode(to), weight, offset, duration);
	}

	public void setEdgeWeight(int fromNode, int toNode, String weight, Timing offset, Timing duration) {
		if (checkForValidIndex(fromNode, toNode, "getEdgeWeight")) {
			generator.setEdgeWeight(this, fromNode, toNode, weight, offset, duration);
		}
	}

	public void setEdgeWeight(Node from, Node to, String weight, Timing offset, Timing duration) {
		setEdgeWeight(getPositionForNode(from), getPositionForNode(to), weight, offset, duration);
	}

	/**
	 * hide a selected graph node by turning it invisible
	 * 
	 * @param index
	 *            the index of the node to be hidden
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void hideNode(int index, Timing offset, Timing duration) {
		if (checkForValidIndex(index, index, "hideNode")) {
			generator.hideNode(this, index, offset, duration);
		}
	}

	public void hideNode(Node node, Timing offset, Timing duration) {
		hideNode(getPositionForNode(node), offset, duration);
	}

	/**
	 * hide a selected set of graph nodes by turning them invisible
	 * 
	 * @param indices
	 *            the set of node indices to be hidden
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void hideNodes(int[] indices, Timing offset, Timing duration) {
		generator.hideNodes(this, indices, offset, duration);
	}

	/**
	 * show a selected (previously visible?) graph edge by turning it invisible
	 * 
	 * @param startNode
	 *            the start node of the edge to be hidden
	 * @param endNode
	 *            the end node of the edge to be hidden
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void hideEdge(int startNode, int endNode, Timing offset, Timing duration) {
		if (checkForValidIndex(startNode, endNode, "hideEdge")) {
			generator.hideEdge(this, startNode, endNode, offset, duration);
		}
	}

	public void hideEdge(Node from, Node to, Timing offset, Timing duration) {
		hideEdge(getPositionForNode(from), getPositionForNode(to), offset, duration);
	}

	/**
	 * hides a selected (previously visible?) graph edge weight by turning it
	 * invisible
	 * 
	 * @param startNode
	 *            the start node of the edge weight to be hidden
	 * @param endNode
	 *            the end node of the edge weight to be hidden
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void hideEdgeWeight(int startNode, int endNode, Timing offset, Timing duration) {
		if (checkForValidIndex(startNode, endNode, "hideEdge")) {
			generator.hideEdgeWeight(this, startNode, endNode, offset, duration);
		}
	}

	public void hideEdgeWeight(Node start, Node to, Timing offset, Timing duration) {
		hideEdgeWeight(getPositionForNode(start), getPositionForNode(to), offset, duration);
	}

	/**
	 * show a selected (previously hidden) graph edge by turning it visible
	 * 
	 * @param startNode
	 *            the start node of the edge to be shown
	 * @param endNode
	 *            the end node of the edge to be hidden
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void showEdge(int startNode, int endNode, Timing offset, Timing duration) {
		if (checkForValidIndex(startNode, endNode, "showEdgeWeight")) {
			generator.showEdge(this, startNode, endNode, offset, duration);
		}
	}

	public void showEdge(Node start, Node to, Timing offset, Timing duration) {
		showEdge(getPositionForNode(start), getPositionForNode(to), offset, duration);
	}

	/**
	 * show a selected (previously invisible?) graph edge weight by turning it
	 * visible
	 * 
	 * @param startNode
	 *            the start node of the edge weight to be shown
	 * @param endNode
	 *            the end node of the edge weightto be shown
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void showEdgeWeight(int startNode, int endNode, Timing offset, Timing duration) {
		if (checkForValidIndex(startNode, endNode, "showEdgeWeight")) {
			generator.showEdgeWeight(this, startNode, endNode, offset, duration);
		}
	}

	public void showEdgeWeight(Node start, Node to, Timing offset, Timing duration) {
		showEdgeWeight(getPositionForNode(start), getPositionForNode(to), offset, duration);
	}

	/**
	 * show a selected (previously hidden) graph node by turning it visible
	 * 
	 * @param index
	 *            the index of the node to be shown
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void showNode(int index, Timing offset, Timing duration) {
		if (checkForValidIndex(index, index, "hideNode")) {
			generator.showNode(this, index, offset, duration);
		}
	}

	public void showNode(Node node, Timing offset, Timing duration) {
		showNode(getPositionForNode(node), offset, duration);
	}

	/**
	 * show a selected (previously hidden) graph node by turning it visible
	 * 
	 * @param indices
	 *            the index of the node to be shown
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void showNodes(int[] indices, Timing offset, Timing duration) {
		generator.showNodes(this, indices, offset, duration);
	}

	/**
	 * Highlights the graph edge at a given position after a distinct offset.
	 * 
	 * @param startNode
	 *            the start node of the edge to highlight.
	 * @param endNode
	 *            the end node of the edge to highlight.
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void highlightEdge(int startNode, int endNode, Timing offset, Timing duration) {
		if (checkForValidIndex(startNode, endNode, "highlightEdge")) {
			if (!((Boolean) getProperties().get(AnimationPropertiesKeys.DIRECTED_PROPERTY)).booleanValue()) {
				int a = Math.min(startNode, endNode), b = Math.max(startNode, endNode);
				generator.highlightEdge(this, a, b, offset, duration);
			} else {
				generator.highlightEdge(this, startNode, endNode, offset, duration);
			}
			// generator.highlightEdge(this, startNode, endNode, offset, duration);
		}
	}

	public void highlightEdge(Node start, Node to, Timing offset, Timing duration) {
		highlightEdge(getPositionForNode(start), getPositionForNode(to), offset, duration);
	}

	/**
	 * Unhighlights the graph edge at a given position after a distinct offset.
	 * 
	 * @param startNode
	 *            the start node of the edge to unhighlight.
	 * @param endNode
	 *            the end node of the edge to unhighlight.
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void unhighlightEdge(int startNode, int endNode, Timing offset, Timing duration) {
		if (checkForValidIndex(startNode, endNode, "unhighlightEdge")) {
			if (!((Boolean) getProperties().get(AnimationPropertiesKeys.DIRECTED_PROPERTY)).booleanValue()) {
				int a = Math.min(startNode, endNode), b = Math.max(startNode, endNode);
				generator.unhighlightEdge(this, a, b, offset, duration);
			} else {
				generator.unhighlightEdge(this, startNode, endNode, offset, duration);
			}
			// generator.unhighlightEdge(this, startNode, endNode, offset, duration);
		}
	}

	public void unhighlightEdge(Node start, Node to, Timing offset, Timing duration) {
		unhighlightEdge(getPositionForNode(start), getPositionForNode(to), offset, duration);
	}

	/**
	 * Highlights the chosen graph node after a distinct offset.
	 * 
	 * @param node
	 *            the node to highlight.
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void highlightNode(int node, Timing offset, Timing duration) {
		if (checkForValidIndex(node, node, "highlightNode")) {
			generator.highlightNode(this, node, offset, duration);
		}
	}

	public void highlightNode(Node node, Timing offset, Timing duration) {
		highlightNode(getPositionForNode(node), offset, duration);
	}

	/**
	 * Unhighlights the chosen graph node after a distinct offset.
	 * 
	 * @param node
	 *            the node to unhighlight.
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void unhighlightNode(int node, Timing offset, Timing duration) {
		if (checkForValidIndex(node, node, "unhighlightNode")) {
			generator.unhighlightNode(this, node, offset, duration);
		}
	}

	public void unhighlightNode(Node node, Timing offset, Timing duration) {
		unhighlightNode(getPositionForNode(node), offset, duration);
	}

	public void translateNode(int nodeIndex, Node location, Timing offset, Timing duration) {
		if (checkForValidIndex(nodeIndex, nodeIndex, "translateNode")) {
			generator.translateNode(this, nodeIndex, location, offset, duration);
		}
	}

	public void translateNode(Node node, Node location, Timing offset, Timing duration) {
		translateNode(getPositionForNode(node), location, offset, duration);
	}

	public void translateWithFixedNodes(int[] nodeIndices, Node location, Timing offset, Timing duration) {
		generator.translateWithFixedNodes(this, nodeIndices, location, offset, duration);
	}

	public void translateNodes(int[] nodeIndices, Node location, Timing offset, Timing duration) {
		generator.translateNodes(this, nodeIndices, location, offset, duration);
	}

	// /**
	// * Returns the upper left corner of this <code>Text</code> element.
	// *
	// * @return the upper left corner of this <code>Text</code> element.
	// */
	// public Node getUpperLeft() {
	// return upperLeft;
	// }

	/**
	 * @see algoanim.primitives.Primitive#setName(java.lang.String)
	 */
	public void setName(String newName) {
		properties.setName(newName);
		super.setName(newName);
	}

	// public void setEdgeWeight(int startNode, int endNode, int weight) {
	// setEdgeWeight(startNode, endNode, String.valueOf(weight));
	// }

	// Madieha
	public void setStartNode(Node node) {
		if (!this.autogenerated)
			this.startNode = node;
		else {

			boolean found = false;
			if (oldNew.get(node) != null)
				node = oldNew.get(node);
			for (Node n : this.nodes) {
				if (n.equals(node)) {
					found = true;
				}
			}
			boolean foundaqui = false;
			if (!found) {

				for (Node n : this.nodes) {
					if (node instanceof Coordinates && n instanceof Coordinates) {
						if (((Coordinates) node).getX() == ((Coordinates) n).getX()
								&& ((Coordinates) node).getY() == ((Coordinates) n).getY()) {
							node = n;
							foundaqui = true;
							break;
						}
					}
				}
				if (!foundaqui)
					node = nodes[0];
			}

			this.startNode = node;
		}

	}

	/**
	 * Use this method if you generated the graph without nodes for setting the
	 * start node for the first time
	 * 
	 * @param label
	 *            label of the start node
	 */
	public void setStartNode(String label) {

		if (label == null) {
			System.out.println("label may not be null");
			return;
		}

		int index = -1;

		for (int i = 0; i < this.nodeLabels.length; i++)
			if (label.equals(nodeLabels[i]))
				index = i;

		if (index == -1) {
			System.out.println("no such label in this graph");
			return;
		}
		this.startNode = this.nodes[index];

	}

	/**
	 * Use this method if you generated the graph without nodes for setting the
	 * target node for the first time
	 * 
	 * @param label
	 *            label of the target node
	 */
	public void setTargetNode(String label) {

		if (label == null) {
			System.out.println("label may not be null");
			return;
		}

		int index = -1;

		for (int i = 0; i < this.nodeLabels.length; i++)
			if (label.equals(nodeLabels[i]))
				index = i;

		if (index == -1) {
			System.out.println("no such label in this graph");
			return;
		}
		this.targetNode = this.nodes[index];

	}

	public void setTargetNode(Node node) {
		if (!this.autogenerated)
			this.targetNode = node;
		else {
			boolean found = false;
			if (oldNew.get(node) != null)
				node = oldNew.get(node);
			for (Node n : this.nodes) {
				if (n.equals(node)) {
					found = true;
				}
			}
			boolean foundaqui = false;
			if (!found) {

				for (Node n : this.nodes) {
					if (node instanceof Coordinates && n instanceof Coordinates) {
						if (((Coordinates) node).getX() == ((Coordinates) n).getX()
								&& ((Coordinates) node).getY() == ((Coordinates) n).getY()) {
							node = n;
							foundaqui = true;
							break;
						}
					}
				}
				if (!foundaqui)
					node = nodes[nodes.length - 1];
			}

			this.targetNode = node;
		}

	}

	public Node getStartNode() {
		if (!this.autogenerated)
			return this.startNode;
		else {
			if (this.startNode == null) {

				if (this.nodes[0] instanceof Coordinates) {

				}
				return this.nodes[0];
			}
			if (this.startNode instanceof Coordinates) {

			}
			if (this.oldNew.get(this.startNode) != null) {
				this.startNode = oldNew.get(this.startNode);
			}

			return this.startNode;
		}

	}

	public Node getTargetNode() {
		if (!this.autogenerated)
			return this.targetNode;
		else {
			if (this.targetNode == null) {
				return this.nodes[nodes.length - 1];
			}

			return this.targetNode;
		}

	}

	/**
	 * Change the HighlightColor of the Node
	 * 
	 * @param node
	 *            position of the node
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void setNodeHighlightFillColor(int node, Color c, Timing offset, Timing duration) {
		if (checkForValidIndex(node, node, "setNodeHighlightFillColor")) {
			generator.setColorType(this, node, "setNodeHighlightFillColor", c, offset, duration);
		}
	}

	public void setNodeHighlightFillColor(Node node, Color c, Timing offset, Timing duration) {
		setNodeHighlightFillColor(getPositionForNode(node), c, offset, duration);
	}

	/**
	 * Change the HighlightColor of the Text in the Node
	 * 
	 * @param node
	 *            position of the node
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void setNodeHighlightTextColor(int node, Color c, Timing offset, Timing duration) {
		if (checkForValidIndex(node, node, "setNodeHighlightTextColor")) {
			generator.setColorType(this, node, "setNodeHighlightTextColor", c, offset, duration);
		}
	}

	public void setNodeHighlightTextColor(Node node, Color c, Timing offset, Timing duration) {
		setNodeHighlightTextColor(getPositionForNode(node), c, offset, duration);
	}

	/**
	 * Change the HighlightColor of an edge text
	 * 
	 * @param node
	 *            position of the node1
	 * @param node
	 *            position of the node2
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void setEdgeHighlightTextColor(int node1, int node2, Color c, Timing offset, Timing duration) {
		if (checkForValidIndex(node1, node2, "setEdgeHighlightTextColor")) {
			generator.setColorType(this, node1, node2, "setEdgeHighlightTextColor", c, offset, duration);
		}
	}

	public void setEdgeHighlightTextColor(Node node1, Node node2, Color c, Timing offset, Timing duration) {
		setEdgeHighlightTextColor(getPositionForNode(node1), getPositionForNode(node2), c, offset, duration);
	}

	/**
	 * Change the HighlightColor of an edge
	 * 
	 * @param node
	 *            position of the node1
	 * @param node
	 *            position of the node2
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void setEdgeHighlightPolyColor(int node1, int node2, Color c, Timing offset, Timing duration) {
		if (checkForValidIndex(node1, node2, "setEdgeHighlightPolyColor")) {
			generator.setColorType(this, node1, node2, "setEdgeHighlightPolyColor", c, offset, duration);
		}
	}

	public void setEdgeHighlightPolyColor(Node node1, Node node2, Color c, Timing offset, Timing duration) {
		setEdgeHighlightPolyColor(getPositionForNode(node1), getPositionForNode(node2), c, offset, duration);
	}

	// TODO Add more setXColor

	public void setNodeLabel(Node node, String label, Timing offset, Timing duration) {
		setNodeLabel(getPositionForNode(node), label, offset, duration);
		if (this.autogenerated)
			node = oldNew.get(node);
	}

	public void setNodeLabel(int node, String label, Timing offset, Timing duration) {
		if (checkForValidIndex(node, node, "setNodeLabel")) {
			nodeLabels[node] = label;
			generator.setNodeLabel(this, node, label, offset, duration);
		}
	}

	/**
	 * Set the radius of a Node. This radius will me fixed until you set the radius
	 * to null or call method setNodeRadiusAuto.
	 * 
	 * @param node
	 *            position of the node
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void setNodeRadius(Node node, Integer radius, Timing offset, Timing duration) {
		setNodeRadius(getPositionForNode(node), radius, offset, duration);
	}

	/**
	 * Set the radius of a Node. This radius will me fixed until you set the radius
	 * to null or call method setNodeRadiusAuto.
	 * 
	 * @param node
	 *            position of the node
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void setNodeRadius(int node, Integer radius, Timing offset, Timing duration) {
		if (checkForValidIndex(node, node, "setNodeRadius")) {
			String radiusString = radius == null ? "null" : String.valueOf(radius.intValue());
			generator.setNodeRadius(this, node, radiusString, offset, duration);
		}
	}

	/**
	 * Set the radius of a Node to automatic resize.
	 * 
	 * @param node
	 *            position of the node
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void setNodeRadiusAuto(Node node, Timing offset, Timing duration) {
		setNodeRadiusAuto(getPositionForNode(node), offset, duration);
	}

	/**
	 * Set the radius of a Node to automatic resize.
	 * 
	 * @param node
	 *            position of the node
	 * @param offset
	 *            [optional] the offset after which the operation shall be started.
	 * @param duration
	 *            [optional] the duration this operation lasts.
	 */
	public void setNodeRadiusAuto(int node, Timing offset, Timing duration) {
		if (checkForValidIndex(node, node, "setNodeRadiusAuto")) {
			String radiusString = "null";
			generator.setNodeRadius(this, node, radiusString, offset, duration);
		}
	}

}
