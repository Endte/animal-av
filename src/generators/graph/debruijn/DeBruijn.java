/*
 * DeBruijn.java
 * Nikola Aleksandrov, 2014 for the Animal project at TU Darmstadt.
 * Copying this file for educational purposes is permitted without further authorization.
 */

package generators.graph.debruijn;

import generators.framework.Generator;
import generators.framework.GeneratorType;
import generators.framework.ValidatingGenerator;
import generators.framework.properties.AnimationPropertiesContainer;

import java.awt.Font;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;
import java.util.Locale;

import javax.swing.JOptionPane;

import algoanim.animalscript.AnimalScript;
import algoanim.primitives.Graph;
import algoanim.primitives.IntMatrix;
import algoanim.primitives.Rect;
import algoanim.primitives.Text;
import algoanim.primitives.generators.Language;
import algoanim.properties.AnimationPropertiesKeys;
import algoanim.properties.GraphProperties;
import algoanim.properties.MatrixProperties;
import algoanim.properties.RectProperties;
import algoanim.properties.TextProperties;
import algoanim.util.Coordinates;
import algoanim.util.Node;
import algoanim.util.Offset;

public class DeBruijn implements ValidatingGenerator {
	private Language language;
	private GraphProperties graphProps;
	private MatrixProperties matrixProps;
	private RectProperties rectProps;
	private TextProperties titleProps;
	private TextProperties textProps;

	private int nthGraph = 0;
	private double distance = 0;
	private boolean generateAllGraphs = false;
	private boolean positionOnCircle = false;

	private Coordinates[] leftStartNodes = new Coordinates[] {
			new Coordinates(100, 200), new Coordinates(200, 200) };
	private Coordinates[] rightStartNodes = new Coordinates[] {
			new Coordinates(300, 300), new Coordinates(600, 300) };
	private Coordinates[] rectCoordinates = new Coordinates[] {
			new Coordinates(20, 20), new Coordinates(270, 80) };
	private Coordinates[] bigRectCoordinates = new Coordinates[] {
			new Coordinates(20, 120), new Coordinates(1000, 500) };

	public DeBruijn(Language language) {
		this.language = language;
		language.setStepMode(true);
	}

	public DeBruijn() {
	}

	@Override
	public void init() {
		this.language = new AnimalScript("De Bruijn", "Nikola Aleksandrov",
				800, 600);
		this.language.setStepMode(true);
	}

	public String generate(AnimationPropertiesContainer props,
			Hashtable<String, Object> primitives) {
		graphProps = (GraphProperties) props.getPropertiesByName("graphProps");
		matrixProps = (MatrixProperties) props
				.getPropertiesByName("matrixProps");
		rectProps = (RectProperties) props.getPropertiesByName("rectProps");
		titleProps = (TextProperties) props.getPropertiesByName("titleProps");
		textProps = (TextProperties) props.getPropertiesByName("textProps");

		this.nthGraph = (int) primitives.get("nthGraph");
		this.generateAllGraphs = (boolean) primitives.get("generateAllGraphs");
		this.distance = (double) primitives.get("distance");
		this.positionOnCircle = (boolean) primitives.get("positionOnCircle");

		titleProps.set(AnimationPropertiesKeys.FONT_PROPERTY, new Font(
				"Monospaced", Font.PLAIN, 24));
		textProps.set(AnimationPropertiesKeys.FONT_PROPERTY, new Font(
				"Monospaced", Font.PLAIN, 12));

		this.showFirstStep();

		if (this.generateAllGraphs) {
			this.generateAnimation(this.nthGraph);
		} else {
			generateSingleGraphAnimation(this.nthGraph);
		}

		this.showLastStep();

		return this.language.toString();
	}

	public void drawDeBruijn(int leftNodes, Node[] leftStartNodes,
			int rightNodes, Node[] rightStartNodes) {
		Rect rect = this.language.newRect(rectCoordinates[0],
				rectCoordinates[1], "rect", null, rectProps);
		Text title = this.language.newText(new Offset(25, 25, "rect",
				AnimalScript.DIRECTION_NW), "De Bruijn Graph", "titleText",
				null, titleProps);

		rect.show();
		title.show();

		Graph lg;
		Graph rg;
		if (leftNodes == 2) {
			lg = constructGraph("left_graph",
					getDeBruijnAdjacencyMatrix(leftNodes), this.leftStartNodes,
					leftNodes);
		} else {
			lg = constructGraph("left_graph",
					getDeBruijnAdjacencyMatrix(leftNodes), leftStartNodes,
					leftNodes);
		}

		rg = constructGraph("right_graph",
				getDeBruijnAdjacencyMatrix(rightNodes), rightStartNodes,
				rightNodes);

		this.showComplexity(lg, rg);
		this.highlightNextGraphNodes(lg, rg);
		this.highlightNextGraphEdges(lg, rg);
		lg.hide();
		rg.hide();

		this.showGraphAndMatrix(lg);
		this.showGraphAndMatrix(rg);
	}

	private void showComplexity(Graph lg, Graph rg) {

		int lgedges = lg.getSize() * 2;
		int rgedges = rg.getSize() * 2;

		String s1 = "Every N th De Bruijn Graph is generated by N - 1 th De Bruij Graph";
		String s2 = "1. Nth De Bruijn Graph has 2 times more nodes and 2 times more edges than N - 1 th De Bruijn Graph";
		String s3 = "2. De Bruijn Graph on the left has " + lg.getSize()
				+ " nodes and " + lgedges + " edges";
		String s4 = "3. De Bruijn Graph on the right has " + rg.getSize()
				+ " nodes and " + rgedges + " edges";

		Text t1 = this.language.newText(new Offset(270, 0, "rect",
				AnimalScript.DIRECTION_NW), s1, "te1", null, textProps);
		Text t2 = this.language.newText(new Offset(0, 25, "te1",
				AnimalScript.DIRECTION_NW), s2, "te2", null, textProps);
		Text t3 = this.language.newText(new Offset(0, 25, "te2",
				AnimalScript.DIRECTION_NW), s3, "te3", null, textProps);
		Text t4 = this.language.newText(new Offset(0, 25, "te3",
				AnimalScript.DIRECTION_NW), s4, "te4", null, textProps);

		this.language.nextStep("Complexity for graph " + lg.getSize()
				+ " graph " + rg.getSize());
		t1.hide();
		t2.hide();
		t3.hide();
		t4.hide();
	}

	private void showFirstStep() {
		this.language.newRect(rectCoordinates[0], rectCoordinates[1], "rect",
				null, rectProps);
		this.language.newText(new Offset(25, 25, "rect",
				AnimalScript.DIRECTION_NW), "De Bruijn Graph", "titleText",
				null, titleProps);

		this.language.newRect(bigRectCoordinates[0], bigRectCoordinates[1],
				"bigrect", null, rectProps);

		this.language
				.newText(
						new Coordinates(30, 130),
						"In graph theory, an N-dimensional De Bruijn graph of M symbols is a directed graph ",
						"first1", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first1", AnimalScript.DIRECTION_NW),
						"representing overlaps between sequences of symbols. It has M^N vertices, consisting ",
						"first2", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first2", AnimalScript.DIRECTION_NW),
						"of all possible length-N sequences of the given symbols. The same symbol may appear multiple times in a sequence. ",
						"first3", null, textProps);
		this.language.newText(new Offset(0, 25, "first3",
				AnimalScript.DIRECTION_NW), "", "first4", null, textProps);
		this.language.newText(new Offset(0, 25, "first4",
				AnimalScript.DIRECTION_NW), "Properties ", "first5", null,
				textProps);
		this.language
				.newText(
						new Offset(0, 25, "first5", AnimalScript.DIRECTION_NW),
						"If N=1 then the condition for any two vertices forming an edge holds vacuously:",
						"first6", null, textProps);
		this.language.newText(new Offset(0, 25, "first6",
				AnimalScript.DIRECTION_NW),
				"1. Each vertex has exactly M incoming and M outgoing edges",
				"first7", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first7", AnimalScript.DIRECTION_NW),
						"2. Each N-dimensional De Bruijn graph is the line digraph of the (N - 1) - dimensional De Bruijn graph with the same set of symbols",
						"first8", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first8", AnimalScript.DIRECTION_NW),
						"3. Each De Bruijn graph is Eulerian and Hamiltonian. The Euler cycles and Hamiltonian cycles of these graphs",
						"first9", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first9", AnimalScript.DIRECTION_NW),
						"4. Each vertex of the N-dimensional De Bruijn graph corresponds to an edge of the (N - 1) - dimensional De Bruijn graph",
						"first10", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first10", AnimalScript.DIRECTION_NW),
						"5. Each edge in the N-dimensional De Bruijn graph corresponds to a two-edge path in the (N - 1) - dimensional De Bruijn graph",
						"first11", null, textProps);

		this.language.newText(new Offset(0, 25, "first11",
				AnimalScript.DIRECTION_NW), "", "first12", null, textProps);

		this.language.newText(new Offset(0, 25, "first12",
				AnimalScript.DIRECTION_NW),
				"Source: http://en.wikipedia.org/wiki/De_Bruijn_graph",
				"first13", null, textProps);

		this.language.nextStep("Initial step");
		this.language.hideAllPrimitives();
	}

	private void showLastStep() {
		this.language.newRect(bigRectCoordinates[0], bigRectCoordinates[1],
				"bigrect", null, rectProps);
		this.language.newText(new Coordinates(30, 130), "Uses:", "first1",
				null, textProps);
		this.language.newText(new Offset(0, 25, "first1",
				AnimalScript.DIRECTION_NW),
				"1. Some grid network topologies are De Bruijn graph",
				"first2", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first2", AnimalScript.DIRECTION_NW),
						"2. The distributed hash table protocol Koorde uses a De Bruijn graph - http://en.wikipedia.org/wiki/Koorde ",
						"first3", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first3", AnimalScript.DIRECTION_NW),
						"3. In bioinformatics, De Bruijn graphs are used for de novo assembly of (short) read sequences into a genome.",
						"first4", null, textProps);
		this.language.newText(new Offset(0, 25, "first4",
				AnimalScript.DIRECTION_NW), "", "first5", null, textProps);
		this.language.newText(new Offset(0, 25, "first5",
				AnimalScript.DIRECTION_NW), "See also:", "first6", null,
				textProps);
		this.language
				.newText(
						new Offset(0, 25, "first6", AnimalScript.DIRECTION_NW),
						"1. De Bruijn sequence - http://en.wikipedia.org/wiki/De_Bruijn_sequence",
						"first7", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first7", AnimalScript.DIRECTION_NW),
						"2. De Bruijn torus - http://en.wikipedia.org/wiki/De_Bruijn_torus",
						"first8", null, textProps);
		this.language.newText(new Offset(0, 25, "first8",
				AnimalScript.DIRECTION_NW),
				"3. Kautz graph - http://en.wikipedia.org/wiki/Kautz_graph",
				"first9", null, textProps);
		this.language.newText(new Offset(0, 25, "first9",
				AnimalScript.DIRECTION_NW),
				"4. Free monoid - http://en.wikipedia.org/wiki/Free_monoid",
				"first10", null, textProps);
		this.language
				.newText(
						new Offset(0, 25, "first10", AnimalScript.DIRECTION_NW),
						"5. Semi automation - http://en.wikipedia.org/wiki/Semiautomaton",
						"first11", null, textProps);
		this.language.newText(new Offset(0, 25, "first11",
				AnimalScript.DIRECTION_NW), "", "first12", null, textProps);
		this.language.newText(new Offset(0, 25, "first12",
				AnimalScript.DIRECTION_NW),
				"Source: http://en.wikipedia.org/wiki/De_Bruijn_graph",
				"first13", null, textProps);
		this.language.nextStep("Last step");

	}

	private void showGraphAndMatrix(Graph g) {

		String txt1 = "Every node in De Bruijn Graph has two outgoing edges that is why every line in the adjacency matrix has two 1";
		String txt2 = "1. First  edge from node i goes to node 2 * i mod graph.size()";
		String txt3 = "2. Second edge from node i goes to node 2 * i mod graph.size() + 1";
		String txt4 = "";

		Text t1 = this.language.newText(new Offset(270, 0, "rect",
				AnimalScript.DIRECTION_NW), txt1, "t1", null, textProps);
		Text t2 = this.language.newText(new Offset(0, 25, "t1",
				AnimalScript.DIRECTION_NW), txt2, "t2", null, textProps);
		Text t3 = this.language.newText(new Offset(0, 25, "t2",
				AnimalScript.DIRECTION_NW), txt3, "t3", null, textProps);
		Text t4 = this.language.newText(new Offset(0, 25, "t3",
				AnimalScript.DIRECTION_NW), txt4, "t4", null, textProps);

		Coordinates firstNode = (Coordinates) g.getNodeForIndex(0);
		Coordinates lastNode = (Coordinates) g.getNodeForIndex(g.getSize() - 1);

		if (this.positionOnCircle) {
			lastNode = (Coordinates) g.getNodeForIndex(g.getSize() / 2);
		}

		int size = g.getSize();
		Coordinates fn = new Coordinates(0, 0);
		Coordinates ln = new Coordinates(0, 0);

		if (firstNode.getX() > 200) {
			fn = new Coordinates(100, firstNode.getY());
			ln = new Coordinates(100 + lastNode.getX() - firstNode.getX(),
					lastNode.getY());
		} else {
			fn = firstNode;
			ln = lastNode;
		}

		Node[] start_nodes = new Node[] { fn, ln };
		Node[] nodes = new Node[size];
		if (this.positionOnCircle) {
			nodes = calculateCircleCoordinates(start_nodes, size);
		} else {
			nodes = createNodes(start_nodes, size);
		}
		Graph ng = this.language.newGraph("newGraph" + size,
				getDeBruijnAdjacencyMatrix(size), nodes,
				createDeBruijnNodeLabels(size), null, this.graphProps);

		Coordinates upperLeft = new Coordinates(ln.getX() + 100, ln.getY());

		IntMatrix matrix = this.language.newIntMatrix(upperLeft,
				getDeBruijnAdjacencyMatrix(ng.getSize()), "matrix", null,
				matrixProps);

		this.language.nextStep("Show graph with " + size
				+ " nodes and its adjacency matrix");

		int[][] deBruijnAdjacencyMatrix = this.getDeBruijnAdjacencyMatrix(g
				.getSize());

		for (int i = 0; i < size; i++) {
			for (int j = 0; j < size; j++) {
				if (deBruijnAdjacencyMatrix[i][j] == 1) {
					t4.hide();
					if (2 * i % size == j) {
						txt4 = "1. First  edge from node " + ng.getNodeLabel(i)
								+ " goes to node 2 * " + i + " mod " + size
								+ " = " + j + " which is node "
								+ ng.getNodeLabel(j);
					} else {
						txt4 = "2. Second edge from node " + ng.getNodeLabel(i)
								+ " goes to node 2 * " + i + " mod " + size
								+ " + 1 = " + j + " which is node "
								+ ng.getNodeLabel(j);
					}

					t4 = this.language.newText(new Offset(0, 25, "t3",
							AnimalScript.DIRECTION_NW), txt4, "t4", null,
							textProps);

					matrix.highlightCell(i, j, null, null);
					Node i_node = ng.getNode(i);
					Node j_node = ng.getNode(j);
					ng.highlightNode(i_node, null, null);
					ng.highlightNode(j_node, null, null);
					ng.highlightEdge(i_node, j_node, null, null);
					this.language.nextStep("Highlight edge from node "
							+ ng.getNodeLabel(i) + " to node "
							+ ng.getNodeLabel(j) + " and matrix element");
					matrix.unhighlightCell(i, j, null, null);
					ng.unhighlightNode(i_node, null, null);
					ng.unhighlightNode(j_node, null, null);
					ng.unhighlightEdge(i_node, j_node, null, null);
				}
			}
		}

		t1.hide();
		t2.hide();
		t3.hide();
		t4.hide();
		matrix.hide();
		ng.hide();
	}

	private static Coordinates[] calculateCircleCoordinates(Node[] start_nodes,
			int nodes) {

		Coordinates a = (Coordinates) start_nodes[0];
		Coordinates b = (Coordinates) start_nodes[1];
		int r = (b.getX() - a.getX()) / 2;
		Coordinates center = new Coordinates(a.getX() + r, a.getY());

		double d = ((double) 360 / nodes);
		int delta = (int) Math.round(d);
		int t = 180;
		ArrayList<Coordinates> coordinates = new ArrayList<Coordinates>();

		for (int i = 0; i < nodes; i++) {
			Double cos = center.getX() + r * Math.cos(Math.toRadians(t));
			Double sin = center.getY() + r * Math.sin(Math.toRadians(t));
			int x = cos.intValue();
			int y = sin.intValue();
			t += delta;
			Coordinates point = new Coordinates(x, y);
			coordinates.add(point);
		}
		Coordinates[] result = new Coordinates[nodes];
		for (int i = 0; i < nodes; i++) {
			result[i] = coordinates.get(i);
		}
		return result;
	}

	private Graph constructGraph(String graph, int[][] graphAdjacencyMatrix,
			Node[] start_nodes, int nodes) {
		Node[] graphNodes = new Node[nodes];

		if (this.positionOnCircle) {
			graphNodes = calculateCircleCoordinates(start_nodes, nodes);
		} else {
			graphNodes = createNodes(start_nodes, nodes);
		}

		String[] labels = createDeBruijnNodeLabels(nodes);
		Graph g = this.language.newGraph(graph, graphAdjacencyMatrix,
				graphNodes, labels, null, graphProps);
		this.language.nextStep("Construct graph with " + nodes + " nodes");
		return g;
	}

	private void highlightNextGraphNodes(Graph lg, Graph rg) {
		int[][] lg_adjacencyMatrix = lg.getAdjacencyMatrix();
		for (int i = 0; i < lg_adjacencyMatrix.length; i++) {
			for (int j = 0; j < lg_adjacencyMatrix[0].length; j++) {
				if (lg_adjacencyMatrix[i][j] != 0) {
					Node i_node = lg.getNode(i);
					Node j_node = lg.getNode(j);

					int node = getIndexForNode(lg.getNodeLabel(i),
							lg.getNodeLabel(j));

					Node rg_node = rg.getNode(node);

					lg.highlightEdge(i_node, j_node, null, null);
					rg.highlightNode(rg_node, null, null);

					String leftNodeLabel = lg.getNodeLabel(i);
					String rightNodeLabel = lg.getNodeLabel(j);
					String resultNodeLabel = rg.getNodeLabel(rg_node);
					String space = "__";
					String plus = " + ";
					String equals = " = ";

					String txt1 = "Edge from node " + leftNodeLabel
							+ " to node " + rightNodeLabel
							+ " on the left generates node " + resultNodeLabel
							+ " on the right";
					String txt2 = "If length of node > 2 than last bit of first node is merged";
					String txt3 = "with first bit of second node, then the result is concatenated";

					int param = leftNodeLabel.length() - 1;
					String newLeftNodeLabel = leftNodeLabel.substring(0,
							leftNodeLabel.length() - param)
							+ space
							+ leftNodeLabel.substring(leftNodeLabel.length()
									- param, leftNodeLabel.length());
					String newRightNodeLabel = rightNodeLabel.substring(0,
							param)
							+ space
							+ rightNodeLabel.substring(param,
									rightNodeLabel.length());

					String preResultNodeLabel = "";
					if (resultNodeLabel.length() > 2) {

						preResultNodeLabel = new StringBuffer(resultNodeLabel)
								.insert(1, space).toString();
						preResultNodeLabel = new StringBuffer(
								preResultNodeLabel).insert(
								preResultNodeLabel.length() - 1, space)
								.toString();
					}

					String txt4 = "";
					if (leftNodeLabel.length() == 1) {
						txt4 = leftNodeLabel + plus + rightNodeLabel + equals
								+ resultNodeLabel;
					} else {
						txt4 = newLeftNodeLabel + plus + newRightNodeLabel
								+ equals + preResultNodeLabel + equals
								+ resultNodeLabel;
					}

					Text text1 = this.language.newText(new Offset(270, 0,
							"rect", AnimalScript.DIRECTION_NW), txt1, "text1",
							null, textProps);

					Text text2 = this.language.newText(new Offset(0, 25,
							"text1", AnimalScript.DIRECTION_NW), txt2, "text2",
							null, textProps);

					Text text3 = this.language.newText(new Offset(0, 25,
							"text2", AnimalScript.DIRECTION_NW), txt3, "text3",
							null, textProps);

					Text text4 = this.language.newText(new Offset(0, 25,
							"text3", AnimalScript.DIRECTION_NW), txt4, "text4",
							null, textProps);

					this.language.nextStep("Highlight edge from "
							+ lg.getNodeLabel(i_node) + " to "
							+ lg.getNodeLabel(j_node) + " and highlight node "
							+ rg.getNodeLabel(rg_node));

					text1.hide();
					text2.hide();
					text3.hide();
					text4.hide();
					lg.unhighlightEdge(i_node, j_node, null, null);
					rg.unhighlightNode(rg_node, null, null);
				}
			}
		}
	}

	private void highlightNextGraphEdges(Graph lg, Graph rg) {
		int[][] rg_adjacencyMatrix = rg.getAdjacencyMatrix();
		for (int i = 0; i < rg_adjacencyMatrix.length; i++) {
			for (int j = 0; j < rg_adjacencyMatrix[0].length; j++) {
				if (rg_adjacencyMatrix[i][j] != 0) {
					Node i_node = rg.getNode(i);
					Node j_node = rg.getNode(j);
					Node[] nodes = findEdgePath(lg, rg, i_node, j_node);
					Node start_node = nodes[0];
					Node middle_node = nodes[1];
					Node end_node = nodes[2];
					String txt0 = "The two edge path on the left "
							+ lg.getNodeLabel(start_node) + " ---> "
							+ lg.getNodeLabel(middle_node) + " ---> "
							+ lg.getNodeLabel(end_node);
					String txt1 = lg.getNodeLabel(start_node) + " ---> "
							+ lg.getNodeLabel(middle_node) + " = "
							+ rg.getNodeLabel(i_node) + " and "
							+ lg.getNodeLabel(middle_node) + " ---> "
							+ lg.getNodeLabel(end_node) + " = "
							+ rg.getNodeLabel(j_node);
					String txt2 = "creates the following edge on the right";
					String txt3 = "from " + rg.getNodeLabel(i_node) + " to "
							+ rg.getNodeLabel(j_node);

					Text text0 = this.language.newText(new Offset(270, 0,
							"rect", AnimalScript.DIRECTION_NW), txt0, "txt0",
							null, textProps);

					Text text1 = this.language.newText(new Offset(0, 25,
							"txt0", AnimalScript.DIRECTION_NW), txt1, "txt1",
							null, textProps);

					Text text2 = this.language.newText(new Offset(0, 25,
							"txt1", AnimalScript.DIRECTION_NW), txt2, "txt2",
							null, textProps);

					Text text3 = this.language.newText(new Offset(0, 25,
							"txt2", AnimalScript.DIRECTION_NW), txt3, "txt3",
							null, textProps);

					lg.highlightNode(start_node, null, null);
					lg.highlightNode(middle_node, null, null);
					lg.highlightNode(end_node, null, null);
					lg.highlightEdge(start_node, middle_node, null, null);
					lg.highlightEdge(middle_node, end_node, null, null);
					rg.highlightEdge(i_node, j_node, null, null);
					this.language.nextStep("Highlight path from node "
							+ lg.getNodeLabel(start_node) + " to node "
							+ lg.getNodeLabel(middle_node) + " to node "
							+ lg.getNodeLabel(end_node)
							+ " and edge from node " + rg.getNodeLabel(i_node)
							+ " to node " + rg.getNodeLabel(j_node));

					text0.hide();
					text1.hide();
					text2.hide();
					text3.hide();
					lg.unhighlightNode(start_node, null, null);
					lg.unhighlightNode(middle_node, null, null);
					lg.unhighlightNode(end_node, null, null);
					lg.unhighlightEdge(start_node, middle_node, null, null);
					lg.unhighlightEdge(middle_node, end_node, null, null);
					rg.unhighlightEdge(i_node, j_node, null, null);
				}
			}
		}
	}

	private Node[] findEdgePath(Graph lg, Graph rg, Node i, Node j) {
		String i_label = rg.getNodeLabel(i);
		String j_label = rg.getNodeLabel(j);
		Node start_node;
		Node middle_node;
		Node end_node;
		String s = i_label.substring(0, i_label.length() - 1);
		String m = i_label.substring(1, i_label.length());
		String e = j_label.substring(1, j_label.length());
		start_node = lg.getNode(getIndexForNode(s));
		middle_node = lg.getNode(getIndexForNode(m));
		end_node = lg.getNode(getIndexForNode(e));
		Node[] nodes = new Node[] { start_node, middle_node, end_node };
		return nodes;
	}

	private int getIndexForNode(String n) {
		int node = Integer.parseInt(n, 2);
		return node;
	}

	private int getIndexForNode(String firstNode, String secondNode) {
		String fn = "";
		String sn = "";
		String number = "";
		int node = 0;
		if (firstNode.length() == 1) {
			node = Integer.parseInt(firstNode + secondNode, 2);
		} else {
			if (firstNode.length() % 2 == 0) {
				fn = firstNode;
				sn = secondNode.substring(secondNode.length() - 1);
				number = fn + sn;
				node = Integer.parseInt(number, 2);
			} else {
				int param = (firstNode.length() - 1) / 2;
				fn = firstNode.substring(0, firstNode.length() - param + 1);
				sn = secondNode.substring(secondNode.length() - param);
				number = fn + sn;
				node = Integer.parseInt(number, 2);
			}
		}
		return node;
	}

	private int[][] getDeBruijnAdjacencyMatrix(int nodes) {
		int[][] graphAdjacencyMatrix = new int[nodes][nodes];
		for (int i = 0; i < graphAdjacencyMatrix.length; i++)
			for (int j = 0; j < graphAdjacencyMatrix[0].length; j++)
				graphAdjacencyMatrix[i][j] = 0;
		setDeBruijnEdges(graphAdjacencyMatrix);
		return graphAdjacencyMatrix;
	}

	public void setDeBruijnEdges(int[][] matrix) {
		int counter = 0;
		for (int j = 0; j < matrix.length; j++) {
			for (int i = 0; i < 2; i++) {
				if (counter < matrix.length) {
					matrix[j][counter] = 1;
				} else {
					counter = 0;
					matrix[j][counter] = 1;
				}
				counter++;
			}
		}
	}

	public static String[] createDeBruijnNodeLabels(int number) {
		int length = Integer.toBinaryString(number).length() - 1;
		ArrayList<String> binaryNumbers = new ArrayList<String>();

		for (int i = 0; i < number; i++) {
			String tmp = Integer.toBinaryString(i);
			if (tmp.length() < length) {
				StringBuilder sb = new StringBuilder(tmp);
				while (sb.length() < length) {
					sb.insert(0, "0");
				}
				tmp = sb.toString();
			}
			binaryNumbers.add(tmp);
		}
		String[] nodes = new String[binaryNumbers.size()];
		for (int i = 0; i < binaryNumbers.size(); i++) {
			nodes[i] = binaryNumbers.get(i);
		}
		return nodes;
	}

	public Node[] createNodes(Node[] start_nodes, int nodes) {
		Node[] newNodes = new Node[nodes];
		List<Coordinates> coordinates = new ArrayList<>();
		int counter = 2;
		if (nodes == 2) {
			return this.leftStartNodes;
		} else {
			while (counter != nodes) {
				int[][] adjacencyMatrix = getDeBruijnAdjacencyMatrix(counter);
				for (int i = 0; i < adjacencyMatrix.length; i++) {
					for (int j = 0; j < adjacencyMatrix[0].length; j++) {
						if (adjacencyMatrix[i][j] == 1) {
							Coordinates A = (Coordinates) start_nodes[i];
							Coordinates B = (Coordinates) start_nodes[j];
							Coordinates point = calculatePoint(A, B);
							coordinates.add(point);
						}
					}
				}

				counter *= 2;
				start_nodes = new Node[counter];
				for (int i = 0; i < coordinates.size(); i++) {
					start_nodes[i] = coordinates.get(i);
				}
				coordinates.clear();
			}

			newNodes = new Node[start_nodes.length];

			for (int i = 0; i < newNodes.length; i++) {
				newNodes[i] = start_nodes[i];
			}
		}

		return newNodes;
	}

	public Coordinates calculatePoint(Coordinates A, Coordinates B) {
		int center_x = (int) (A.getX() + 0.5 * (B.getX() - A.getX()));
		int center_y = (int) (A.getY() + 0.5 * (B.getY() - A.getY()));

		int AToCenter_x = center_x - A.getX();
		int AToCenter_y = center_y - A.getY();

		int length_acenter = (int) Math.sqrt(AToCenter_x * AToCenter_x
				+ AToCenter_y * AToCenter_y);

		length_acenter *= this.distance;

		int centerToA_x = A.getX();
		int centerToA_y = A.getY() - center_y;

		int alpha = (int) Math.atan(centerToA_y / centerToA_x);

		int t = 0;

		if (A.getX() < B.getX()) {
			t = alpha - 90;
		} else if (A.getX() == B.getX()) {
			if (A.getY() < B.getY()) {
				t = alpha + 180;
			} else {
				t = alpha;
			}
		} else {
			t = alpha + 90;
		}

		Double cos = center_x + length_acenter * Math.cos(Math.toRadians(t));
		Double sin = center_y + length_acenter * Math.sin(Math.toRadians(t));

		int xCoordinate = cos.intValue();
		int yCoordinate = sin.intValue();

		Coordinates point = new Coordinates(xCoordinate, yCoordinate);
		return point;
	}

	private Coordinates[][] calculateStartNodes(int step) {
		Coordinates[][] start_nodes = new Coordinates[2][2];
		Coordinates tmp_left_first_node = this.leftStartNodes[0];
		Coordinates tmp_left_last_node = this.leftStartNodes[1];
		Coordinates tmp_right_first_node = this.rightStartNodes[0];
		Coordinates tmp_right_last_node = this.rightStartNodes[1];

		if (step != 0) {
			int left_first_node_x = 0;
			int left_first_node_y = 0;
			int left_last_node_x = 0;
			int left_last_node_y = 0;

			int right_first_node_x = 0;
			int right_first_node_y = 0;
			int right_last_node_x = 0;
			int right_last_node_y = 0;

			for (int i = 0; i < step; i++) {
				left_first_node_x = 100;
				left_last_node_x = tmp_right_last_node.getX()
						- tmp_right_first_node.getX() + 100;
				right_first_node_x = left_last_node_x + 100;
				right_last_node_x = right_first_node_x * 2;

				left_first_node_y = (int) (0.8 * (left_last_node_x - left_first_node_x));
				left_last_node_y = left_first_node_y;
				right_first_node_y = (int) (0.8 * (right_last_node_x - right_first_node_x));
				right_last_node_y = right_first_node_y;

				tmp_left_first_node = new Coordinates(left_first_node_x,
						left_first_node_y);
				tmp_left_last_node = new Coordinates(left_last_node_x,
						left_last_node_y);
				tmp_right_first_node = new Coordinates(right_first_node_x,
						right_first_node_y);
				tmp_right_last_node = new Coordinates(right_last_node_x,
						right_last_node_y);
			}
			start_nodes[0][0] = tmp_left_first_node;
			start_nodes[0][1] = tmp_left_last_node;
			start_nodes[1][0] = tmp_right_first_node;
			start_nodes[1][1] = tmp_right_last_node;
		} else {
			start_nodes[0][0] = this.leftStartNodes[0];
			start_nodes[0][1] = this.leftStartNodes[1];
			start_nodes[1][0] = this.rightStartNodes[0];
			start_nodes[1][1] = this.rightStartNodes[1];
		}
		return start_nodes;
	}

	public void generateAnimation(int level) {
		Node[][] start_nodes = new Node[2][2];
		for (int i = 0; i < level; i++) {
			start_nodes = calculateStartNodes(i);
			int lgNumberNodes = (int) Math.pow(2, i + 1);
			int rgNumberNodes = (int) Math.pow(2, i + 2);
			drawDeBruijn(lgNumberNodes, start_nodes[0], rgNumberNodes,
					start_nodes[1]);
		}
	}

	public void generateSingleGraphAnimation(int level) {
		Node[][] start_nodes = new Node[2][2];
		start_nodes = calculateStartNodes(level);
		int lgNumberNodes = (int) Math.pow(2, level);
		int rgNumberNodes = (int) Math.pow(2, level + 1);
		drawDeBruijn(lgNumberNodes, start_nodes[0], rgNumberNodes,
				start_nodes[1]);
	}

	public String getName() {
		return "De Bruijn";
	}

	public String getAlgorithmName() {
		return "De Bruijn";
	}

	public String getAnimationAuthor() {
		return "Nikola Aleksandrov";
	}

	public String getDescription() {
		return "In graph theory, an N-dimensional De Bruijn graph of M symbols is a directed graph "
				+ "\n"
				+ "representing overlaps between sequences of symbols. It has M^N vertices, consisting"
				+ "\n"
				+ " of all possible length-N sequences of the given symbols. The same symbol may appear"
				+ "\n"
				+ " multiple times in a sequence. "
				+ "\n"
				+ "\n"
				+ "If we have the set of M symbols 	"
				+ "\n"
				+ "\n"
				+ "	S := {s_1, ... , s_M}  	"
				+ "\n"
				+ "\n"
				+ "then the set of vertices is:"
				+ "\n"
				+ "\n"
				+ "	 V = S ^ N = {(s_1, ... , s_1, s_1), (s_1, ... , s_1, s_2), ... ,(s_1, ... , s_1, s_M),( s_1, ..., s_2, s_1), ... ,( s_M, ... , s_M, s_M)}."
				+ "\n"
				+ "\n"
				+ "If one of the vertices can be expressed as another vertex by shifting all its symbols by one place to the left and adding a new symbol"
				+ "\n"
				+ "at the end of this vertex, then the latter has a directed edge to the former vertex. Thus the set of arcs (aka directed edges) is"
				+ "\n"
				+ "\n"
				+ "    E = { ( ( v_1, v_2, ... , v_N ) , ( v_2, ... , v_N, s_i )) : i = 1 , ... , M }"
				+ "\n"
				+ "\n"
				+ "Properties"
				+ "\n"
				+ "\n"
				+ "If N=1 then the condition for any two vertices forming an edge holds vacuously, and hence all the vertices are connected forming a total of M ^ 2 edges."
				+ "\n"
				+ "\n"
				+ "1. Each vertex has exactly M incoming and M outgoing edges."
				+ "\n"
				+ "2. Each N-dimensional De Bruijn graph is the line digraph of the (N - 1) - dimensional De Bruijn graph with the same set of symbols."
				+ "\n"
				+ "3. Each De Bruijn graph is Eulerian and Hamiltonian. The Euler cycles and Hamiltonian cycles of these graphs "
				+ "\n"
				+ "(equivalent to each other via the line graph construction) are De Bruijn sequences."
				+ "\n"
				+ "4. Each vertex of the N-dimensional De Bruijn graph corresponds to an edge of the (N - 1) - dimensional De Bruijn graph"
				+ "\n"
				+ "5. Each edge in the N-dimensional De Bruijn graph corresponds to a two-edge path in the (N - 1) - dimensional De Bruijn graph."
				+ "\n";
	}

	public String getCodeExample() {
		return "For every edge in graph (N - 1):"
				+ "\n"
				+ "	Start Node - where the edge starts , End Node - where the edge ends"
				+ "\n"
				+ "	s - number of symbols of Start and End nodes"
				+ "\n"
				+ "	if ( s > 1) {"
				+ "\n"
				+ "		New Node for graph N = concatenation of first (s - 1) symbols of Start Node + last (s - 1) symbols of End Node"
				+ "\n"
				+ "	}"
				+ "\n"
				+ "	else{"
				+ "\n"
				+ "		New Node for graph N = concatenation of symbols of Start Node + symbols of End Node"
				+ "\n"
				+ "	}"
				+ "\n"
				+ "	"
				+ "\n"
				+ "For every two-edge path in graph (N - 1):"
				+ "\n"
				+ "	Start Node - where the first edge starts, Middle Node - where the first edge ands and the second edge starts, End Node, where the second edge ends"
				+ "\n"
				+ "	Find Node A from graph N where = concatenation of first (s - 1) symbols of Start Node + last (s - 1) symbols of Middle Node"
				+ "\n"
				+ "	Find Node B from graph N where = concatenation of first (s - 1) symbols of Middle Node + last (s - 1) symbols of End Node"
				+ "\n" + "	Create edge between node A and node B";
	}

	public String getFileExtension() {
		return "asu";
	}

	public Locale getContentLocale() {
		return Locale.ENGLISH;
	}

	public GeneratorType getGeneratorType() {
		return new GeneratorType(GeneratorType.GENERATOR_TYPE_GRAPH);
	}

	public String getOutputLanguage() {
		return Generator.JAVA_OUTPUT;
	}

	@Override
	public boolean validateInput(AnimationPropertiesContainer props,
			Hashtable<String, Object> primitives)
			throws IllegalArgumentException {

		if ((int) primitives.get("nthGraph") <= 0) {
			JOptionPane.showMessageDialog(null, "nthGraph should be > 0");
			return false;
		} else if ((double) primitives.get("distance") <= 0) {
			JOptionPane.showMessageDialog(null, "distance should be > 0");
			return false;
		}
		return true;
	}

}