package generators.tree.rbtree_helper;

import generators.graphics.helpers.Coordinate;

import java.awt.Color;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashSet;

import algoanim.primitives.Graph;
import algoanim.primitives.generators.Language;
import algoanim.properties.AnimationPropertiesKeys;
import algoanim.properties.GraphProperties;
import algoanim.util.Coordinates;

/**
 * Class for representing an RedBlack-Tree.
 * 
 * Code generated by the help of pseudocode in:
 * Introduction to Algorithms, Charles E. Leiserson, 
 * Clifford Stein, Ronald L. Rivest, Thomas H. Cormen
 * 
 * @author Florian Breitfelder, Patrick Jattke
 *
 */
public class Tree {

	private Node root;
	private ArrayList<Node> nodes;
	private int nodesCnt = 0;
	public static Nil nil = new Nil();
	private static int maxLayer = 0;

	private Graph backGraph;
	private Graph frontGraph;
	
	private Color color_currentNode;

	public Tree(int[] values, Language lang, Color color) {
		//this.nil.setParent(this.nil);
		Tree.nil.setParent(Tree.nil);
		this.color_currentNode = color;
		createTree(values);
		convertTreeToGraph(lang);
	}

	public Node getRoot() {
		return root;
	}

	/**
	 * Makes a left rotation of the tree on node x.
	 * 
	 * @param x
	 *            The node on which the tree is rotated.
	 */
	private void leftRotate(Node x) {
		Node y = x.getRightChild();
		x.setRightChild(y.getLeftChild());

		if (y.getLeftChild() != nil) {
			y.getLeftChild().setParent(x);
		}
		y.setParent(x.getParent());
		if (x.getParent() == nil) {
			this.root = y;
		} else if (x == x.getParent().getLeftChild()) {
			x.getParent().setLeftChild(y);
		} else {
			x.getParent().setRightChild(y);
		}
		y.setLeftChild(x);
		x.setParent(y);
	}

	/**
	 * Makes a right rotation of the tree on node y.
	 * 
	 * @param y
	 *            The node on which the tree is rotated.
	 */
	private void rightRotate(Node y) {
		Node x = y.getLeftChild();
		y.setLeftChild(x.getRightChild());
		if (x.getRightChild() != nil) {
			x.getRightChild().setParent(y);
		}
		x.setParent(y.getParent());
		if (y.getParent() == nil) {
			this.root = x;
		} else if (y == y.getParent().getRightChild()) {
			y.getParent().setRightChild(x);
		} else {
			y.getParent().setLeftChild(x);
		}
		x.setRightChild(y);
		y.setParent(x);
	}

	/**
	 * Inserts a given node into the tree.
	 * 
	 * @param z
	 *            The node to insert into the tree.
	 */
	public void insert(Node z) {
		Node y = nil;
		Node x = this.root;

		while (x != nil) {
			y = x;
			if (z.getKey() < x.getKey()) {
				x = x.getLeftChild();
			} else {
				x = x.getRightChild();
			}
		}
		z.setParent(y);
		if (y == nil) {
			this.root = z;
		} else if (z.getKey() < y.getKey()) {
			y.setLeftChild(z);
		} else {
			y.setRightChild(z);
		}
		z.setLeftChild(nil);
		z.setRightChild(nil);
		z.setRed(true);
		if (!(z instanceof Nil)) {
			nodesCnt = nodesCnt + 1;
			nodes.add(z);
		}
		this.insertFixup(z);
	}

	/**
	 * Function which is called after inserting a node into the tree. Repairs
	 * possibly violations of the RedBlack-Tree properties.
	 * 
	 * @param z
	 *            The node which was recently inserted into the tree.
	 */
	private void insertFixup(Node z) {
		while (z.getParent().isRed()) {
			if (z.getParent() == z.getParent().getParent().getLeftChild()) {
				Node y = z.getParent().getParent().getRightChild();
				if (y.isRed()) {
					z.getParent().setRed(false);
					y.setRed(false);
					z.getParent().getParent().setRed(true);
					z = z.getParent().getParent();
				} else {
					if (z == z.getParent().getRightChild()) {
						z = z.getParent();
						this.leftRotate(z);
					}
					z.getParent().setRed(false);
					z.getParent().getParent().setRed(true);
					this.rightRotate(z.getParent().getParent());
				}
			} else {
				Node y = z.getParent().getParent().getLeftChild();
				if (y.isRed()) {
					z.getParent().setRed(false);
					y.setRed(false);
					z.getParent().getParent().setRed(true);
					z = z.getParent().getParent();
				} else {
					if (z == z.getParent().getLeftChild()) {
						z = z.getParent();
						this.rightRotate(z);
					}
					z.getParent().setRed(false);
					z.getParent().getParent().setRed(true);
					this.leftRotate(z.getParent().getParent());
				}
			}
		}
		this.root.setRed(false);
	}

	/**
	 * Returns the number of nodes (except the NIL node).
	 * 
	 * @return number of nodes as int
	 */
	public int getNodesCnt() {
		return nodesCnt;
	}

	/**
	 * Returns an ArrayList of nodes, where all nodes of the tree (except the
	 * NIL node) are in. The nodes in the list are sorted (ascending "<=") by
	 * their id.
	 * 
	 * @return an ArrayList of nodes in the tree
	 */
	public ArrayList<Node> getNodes() {
		nodes.sort(new Comparator<Node>() {
			@Override
			public int compare(Node o1, Node o2) {
				return Integer.valueOf(o1.getId()).compareTo(
						Integer.valueOf(o2.getId()));
			}
		});
		return nodes;
	}

	/**
	 * Returns the node object with the given ID.
	 * 
	 * @param ID
	 *            The Id of the node to search for
	 * @return the node object if the node was found, otherwise null
	 */
	public Node getNodeByID(int ID) {
		for (Node n : nodes) {
			if (n.getId() == ID)
				return n;
		}
		return null;
	}
	
	/**
	 * Returns the node object with the given key.
	 * 
	 * @param key 
	 * 			The key of the node to search for
	 * @return the node object if the node was found, otherwise null
	 */
	public Node getNodeByKey(int key) {
		for (Node n: nodes) {
			if (n.getKey() == key) 
				return n;
		}
		return null;
	}

	/*
	 * Printing code taken from
	 * http://en.literateprograms.org/Red-black_tree_%28Java%29#Printing
	 */

	/**
	 * Prints the tree with the nodes in horizontal order (root is leftmost
	 * tree). Each node is printed as "KEY|SIZE". Red nodes are printed as
	 * "<KEY|SIZE>".
	 * Useful for debugging purposes :-)
	 */
	public void printKeys() {
		printHelper(this.root, 0);
	}

	/**
	 * Recursive function used to print the keys|size of nodes in horizontal
	 * order.
	 * 
	 * @param n
	 *            The starting node (usually root node) to print
	 * @param indent
	 *            The initial indentation of the node (starting value
	 *            recommended: 0)
	 */
	private static void printHelper(Node n, int indent) {
		int INDENT_STEP = 15;
		if (n == null) {
			System.out.print("<empty tree>");
			return;
		}
		if (n.getRightChild() != null) {
			printHelper(n.getRightChild(), indent + INDENT_STEP);
		}
		for (int i = 0; i < indent; i++)
			System.out.print(" ");
		if (n.isRed() == false)
			System.out.println(n.getKey() + "|" + n.getSize());
		else
			System.out.println("<" + n.getKey() + "|" + n.getSize() + ">");
		if (n.getLeftChild() != null) {
			printHelper(n.getLeftChild(), indent + INDENT_STEP);
		}
	}

	/**
	 * Prints the tree with the nodes in horizontal order (root is leftmost
	 * tree). Each node is printed as "ID|SIZE". Red nodes are printed as
	 * "<ID|SIZE>".
	 * Useful for debugging purposes :-)
	 */
	public void printIDs() {
		printHelperID(this.root, 0);
	}

	/**
	 * Recursive function used to print the id|size of nodes in horizontal
	 * order.
	 * 
	 * @param n
	 *            The starting node (usually root node) to print
	 * @param indent
	 *            The initial indentation of the node (starting value
	 *            recommended: 0)
	 */
	private static void printHelperID(Node n, int indent) {
		int INDENT_STEP = 15;
		if (n == null) {
			System.out.print("<empty tree>");
			return;
		}
		if (n.getRightChild() != null) {
			printHelperID(n.getRightChild(), indent + INDENT_STEP);
		}
		for (int i = 0; i < indent; i++)
			System.out.print(" ");
		if (n.isRed() == false)
			System.out.println(n.getId() + "|" + n.getSize());
		else
			System.out.println("<" + (n.getId() + "|" + n.getSize()) + ">");
		if (n.getLeftChild() != null) {
			printHelperID(n.getLeftChild(), indent + INDENT_STEP);
		}
	}

	/**
	 * Converts a given Tree (RB-Tree) to a algoanim.primitives.Graph.
	 * <ul>
	 * <li>Creates an adjacency matrix of the tree</li>
	 * <li>Creates the nodes and sets the correct position within the tree</li>
	 * <li>Sets the color property to 'red' for red nodes</li>
	 * <li>Gives each node the name 'key|size' with the corresponding values</li>
	 * </ul>
	 * 
	 * @param lang
	 *            The language object, which will be used to create the graph
	 * @param this
	 *            The tree which should be used to create a graph of
	 * @return The algoanim.primitives.Graph created of the tree
	 */
	private void convertTreeToGraph(Language lang) {
		// define the edges of the graph
		int nodesNum = this.getNodesCnt();
		int[][] graphAdjacencyMatrix = new int[nodesNum][nodesNum];

		// initialize adjacency matrix with zeros
		for (int i = 0; i < graphAdjacencyMatrix.length; i++)
			for (int j = 0; j < graphAdjacencyMatrix[0].length; j++)
				graphAdjacencyMatrix[i][j] = 0;

		ArrayList<Node> nodes = this.getNodes();

		// connect nodes (0: not connected, 1: connected)
		int ownID;
		for (Node n : nodes) {
			ownID = n.getId();
			if (n.getLeftChild() != null && n.getLeftChild().getId() != -1) {
				int lcID = n.getLeftChild().getId();
				graphAdjacencyMatrix[ownID][lcID] = 1;
				graphAdjacencyMatrix[lcID][ownID] = 1;
			}
			if (n.getRightChild() != null && n.getRightChild().getId() != -1) {
				int rcID = n.getRightChild().getId();
				graphAdjacencyMatrix[ownID][rcID] = 1;
				graphAdjacencyMatrix[rcID][ownID] = 1;
			}
		}

		// define the new nodes and their positions
		algoanim.util.Node[] graphNodes = new algoanim.util.Node[nodesNum];

		// width of a node
		int nodeWidth = 30;
		double stretchFactor = 0.5; // 2.0 = 200 %
		// minimum x-offset between nodes
		int xOffsetMin = (int) ((1 + stretchFactor) * nodeWidth);
		int xOffset = xOffsetMin * (2 * maxLayer);
		// y-offset between nodes
		int yOffset = 2 * nodeWidth;

		HashSet<Integer> redNodes = new HashSet<Integer>();
		int xPos = getXOffset(this.getRoot(), 0, 0, xOffset, yOffset);
		xPos += nodeWidth;
		int yPos = yOffset;
		this.getRoot().setPosition(new Coordinate(xPos, yPos+200));
		positionizeNodes(this.getRoot(), this.getRoot().getPosition().getX(), this.getRoot().getPosition().getY(), xOffset, yOffset);

		int[] nodeIDs = new int[nodes.size()];
		for (Node n : nodes) {
			// find red nodes and color them
			if (n.isRed()) {
				redNodes.add(n.getId());
			}
			// set coordinates into graphNodes
			graphNodes[n.getId()] = new Coordinates(n.getPosition().getX(), n
					.getPosition().getY());
			nodeIDs[n.getId()] = n.getId();

		}

		// define names of the nodes
		String[] labels = new String[nodesNum];
		Node curNode;
		for (int i = 0; i < nodes.size(); i++) {
			curNode = nodes.get(i);
			labels[i] = curNode.getKey() + "|" + curNode.getSize();
		}

		GraphProperties backGraphProps = new GraphProperties();
		backGraphProps.set(AnimationPropertiesKeys.FILLED_PROPERTY, true);
		backGraphProps.set(AnimationPropertiesKeys.FILL_PROPERTY, Color.GRAY);
		backGraphProps.set(AnimationPropertiesKeys.HIGHLIGHTCOLOR_PROPERTY,
				Color.RED);
		backGraphProps.set(AnimationPropertiesKeys.DEPTH_PROPERTY, 1);

		GraphProperties frontGraphProps = new GraphProperties();
		frontGraphProps.set(AnimationPropertiesKeys.FILLED_PROPERTY, true);
		frontGraphProps
				.set(AnimationPropertiesKeys.FILL_PROPERTY, this.color_currentNode);
		frontGraphProps.set(AnimationPropertiesKeys.HIGHLIGHTCOLOR_PROPERTY,
				this.color_currentNode);
		frontGraphProps.set(AnimationPropertiesKeys.DEPTH_PROPERTY, 1);
		// create Graph
		backGraph = lang.newGraph("backGraph", graphAdjacencyMatrix,
				graphNodes, labels, null, backGraphProps);

		frontGraph = lang.newGraph("frontGraph", graphAdjacencyMatrix,
				graphNodes, labels, null, frontGraphProps);

		for (int nodeID : nodeIDs) {
			frontGraph.hideNode(nodeID, null, null);
		}

		for (Integer nodeID : redNodes) {
			backGraph.highlightNode(nodeID, null, null);
			frontGraph.highlightNode(nodeID, null, null);
		}

	}

	/**
	 * Recursive function which calculates the position of each node within a
	 * tree.
	 * 
	 * @param rootNode
	 *            The root node (starting point of recursion)
	 * @param xPos
	 *            The initial x-coordinate value
	 * @param yPos
	 *            The initial y-coordinate value
	 * @param xOffset
	 *            The offset/distance between two nodes within a layer
	 * @param yOffset
	 *            The offset/distance between two layers within a tree
	 */
	private static void positionizeNodes(Node rootNode, int xPos, int yPos,
			int xOffset, int yOffset) {

		if (rootNode.getLeftChild() != Tree.nil) {
			Node leftChild = rootNode.getLeftChild();
			Coordinate position = new Coordinate(xPos - xOffset, yPos + yOffset);
			leftChild.setPosition(position);
			positionizeNodes(leftChild, position.getX(), position.getY(),
					(xOffset / 2), yOffset);
		}

		if (rootNode.getRightChild() != Tree.nil) {
			Node rightChild = rootNode.getRightChild();
			Coordinate position = new Coordinate(xPos + xOffset, yPos + yOffset);
			rightChild.setPosition(position);
			positionizeNodes(rightChild, position.getX(), position.getY(),
					(xOffset / 2), yOffset);
		}

	}

	/**
	 * Recursive function which goes down a tree, starting from a given node n,
	 * to the leftmost node
	 * 
	 * @param n
	 *            The starting node for recursion (usually root node)
	 * @param xPos
	 *            Should be 0 at the initial function call
	 * @param yPos
	 *            Should be 0 at the initial function call
	 * @param xOffset
	 *            The offset between two nodes in the same layer
	 * @param yOffset
	 *            The offset between two layers within the tree
	 * @return
	 */
	private static int getXOffset(Node n, int xPos, int yPos, int xOffset,
			int yOffset) {

		if (n.getLeftChild() != Tree.nil) {
			Node leftChild = n.getLeftChild();
			Coordinate position = new Coordinate(xPos - xOffset, yPos + yOffset);
			leftChild.setPosition(position);
			return getXOffset(leftChild, position.getX(), position.getY(),
					(xOffset / 2), yOffset);
		} else {
			return Math.abs(xPos);
		}

	}

	/**
	 * Creates a Tree of a given int array of keys.
	 * 
	 * @param keys
	 *            The array of keys to insert into the new tree
	 * @return The tree object
	 */
	private Tree createTree(int[] keys) {
		// this is necessary because otherwise the node identifier will count on
		// and new nodes will not receive IDs starting from 0 
		// -> rises errors when convertTreeToGraph is invoked
		Node.resetIDCounter();
		
		// create tree with root node
		Node rootNode = new Node(Tree.nil, Tree.nil, keys[0], false);
		Tree tree = this;

		tree.root = rootNode;
		this.root.setParent(nil);
		nodesCnt = 1;
		nodes = new ArrayList<Node>();
		nodes.add(root);

		// insert elements into tree - one by one
		for (int i = 1; i < keys.length; i++) {
			Node n = new Node(Tree.nil, Tree.nil, keys[i], true);
			tree.insert(n);
		}

		// set layer for each node in tree
		tree.getRoot().setLayer(0);
		tree.getRoot().setPositionInLayer(0);
		setLayer(tree.getRoot());

		// set position in layer for each node in tree
		nodes = tree.getNodes();
		ArrayList<Node> tempNodes = new ArrayList<Node>();
		for (int i = maxLayer; i > 0; i--) {
			// get all nodes with layer i
			for (Node n : nodes) {
				if (n.getLayer() == i) {
					tempNodes.add(n);
				}
			}

			// sort nodes within current layer
			tempNodes.sort(new Comparator<Node>() {
				@Override
				public int compare(Node o1, Node o2) {
					return Integer.valueOf(o1.getKey()).compareTo(
							Integer.valueOf(o2.getKey()));
				}
			});

			// set position of nodes
			for (int j = 0; j < tempNodes.size(); j++) {
				tempNodes.get(j).setPositionInLayer(j);
			}
			tempNodes.clear();
		}

		return tree;
	}

	/**
	 * Recursive function which sets the layer attribute of each node within a
	 * tree.
	 * 
	 * @param node
	 *            The starting node (usually root node) of the tree
	 */
	private static void setLayer(Node node) {
		if (node != Tree.nil && node.getLeftChild() != Tree.nil) {
			Node n = node.getLeftChild();
			int currentLayer = node.getLayer() + 1;
			n.setLayer(currentLayer);
			maxLayer = currentLayer > maxLayer ? currentLayer : maxLayer;
			setLayer(n);
		}

		if (node != Tree.nil && node.getRightChild() != Tree.nil) {
			Node n = node.getRightChild();
			int currentLayer = node.getLayer() + 1;
			n.setLayer(currentLayer);
			maxLayer = currentLayer > maxLayer ? currentLayer : maxLayer;
			setLayer(n);
		}
	}

	public void highlightNode(int nodeID) {
		if(nodeID>=0)
		frontGraph.showNode(nodeID, null, null);
	}

	public void unhighlightNode(int nodeID) {
		if(nodeID>=0)
		frontGraph.hideNode(nodeID, null, null);
	}

}
