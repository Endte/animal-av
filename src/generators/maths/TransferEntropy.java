/*
 * TransferEntropy.java
 * Kenten Fina, 2016 for the Animal project at TU Darmstadt.
 * Copying this file for educational purposes is permitted without further authorization.
 */
package generators.maths;

import java.awt.Color;
import java.awt.Font;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;

import algoanim.animalscript.AnimalScript;
import algoanim.primitives.IntArray;
import algoanim.primitives.Polyline;
import algoanim.primitives.Primitive;
import algoanim.primitives.Rect;
import algoanim.primitives.SourceCode;
import algoanim.primitives.Text;
import algoanim.primitives.generators.Language;
import algoanim.properties.AnimationPropertiesKeys;
import algoanim.properties.ArrayProperties;
import algoanim.properties.MatrixProperties;
import algoanim.properties.PolylineProperties;
import algoanim.properties.RectProperties;
import algoanim.properties.SourceCodeProperties;
import algoanim.properties.TextProperties;
import algoanim.util.Coordinates;
import algoanim.util.MsTiming;
import algoanim.util.Node;
import algoanim.util.Offset;
import algoanim.util.Timing;
import generators.framework.GeneratorType;
import generators.framework.ValidatingGenerator;
import generators.framework.properties.AnimationPropertiesContainer;

public class TransferEntropy implements ValidatingGenerator {

    // AutoGenerated Objects:
    protected Language lang;

    protected SourceCodeProperties code;
    protected int window_size_y;
    protected int window_size_x;
    protected int[] plain_xdata;
    protected int[] plain_ydata;

    // Styles:
    protected TextProperties TP_title;
    protected TextProperties TP_subtitle;
    protected RectProperties RP_titlebox;
    protected ArrayProperties AP_sourcedata;
    protected SourceCodeProperties SP_phases;
    protected SourceCodeProperties SP_code;
    protected PolylineProperties PP_IndexPointer;
    protected TextProperties TP_datainfo;
    protected TextProperties TP_matrix;
    protected RectProperties RP_bgmatrix;
    protected MatrixProperties MP_mapentry;
    protected TextProperties TP_TEacc;
    protected TextProperties TP_TEplus;

    protected Timing localTimer_250ms;

    // Objects:
    protected SourceCode SPhaseCode;
    protected Text TitleText;
    protected Text SubTitleText;
    protected Rect SubTitleBox;
    protected Rect TitleBox;
    protected IntArray xdata, ydata;
    protected Polyline IndexPointer;
    protected Text accTEText;
    protected Text bucketText;

    protected ArrayList<Primitive> ListTitle = new ArrayList<Primitive>();
    protected int bucket_count;

    protected DecimalFormat localFormat;

    // Calculation Data:
    protected java.util.List<TEPair<List<Text>, Rect>> xy1_grids;
    protected java.util.List<TEPair<List<Integer>, Integer>> xy1_list;
    protected java.util.List<Text> xy1_texts;

    protected java.util.List<TEPair<List<Text>, Rect>> xy_grids;
    protected java.util.List<TEPair<List<Integer>, Integer>> xy_list;
    protected java.util.List<Text> xy_texts;

    protected java.util.List<TEPair<List<Text>, Rect>> y1_grids;
    protected java.util.List<TEPair<List<Integer>, Integer>> y1_list;
    protected java.util.List<Text> y1_texts;

    protected java.util.List<TEPair<List<Text>, Rect>> y_grids;
    protected java.util.List<TEPair<List<Integer>, Integer>> y_list;
    protected java.util.List<Text> y_texts;
    
    public TransferEntropy() {
    	init();
	}

    @Override
    public void init(){
        lang = new AnimalScript("Transfer Entropy", "Kenten Fina", 800, 600);
        InitAnimationProps();
    }

    private void InitAnimationProps() {
        TP_title = new TextProperties("Title");
        TP_title.set( AnimationPropertiesKeys.FONT_PROPERTY, new Font("SansSerif", Font.BOLD, 25) );
        TP_title.set( AnimationPropertiesKeys.COLOR_PROPERTY, Color.WHITE );

        TP_subtitle = new TextProperties("SubTitle");
        TP_subtitle.set( AnimationPropertiesKeys.FONT_PROPERTY, new Font("SansSerif", Font.BOLD, 20) );
        TP_subtitle.set( AnimationPropertiesKeys.COLOR_PROPERTY, Color.WHITE );

        TP_datainfo = new TextProperties("InfoData");
        TP_datainfo.set( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK );
        TP_datainfo.set( AnimationPropertiesKeys.FONT_PROPERTY, new Font("SansSerif", Font.PLAIN, 12) );

        TP_TEacc = new TextProperties("TE Value");
        TP_TEacc.set( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK );
        TP_TEacc.set( AnimationPropertiesKeys.FONT_PROPERTY, new Font("SansSerif", Font.BOLD, 14) );

        TP_TEplus = new TextProperties("TE Value");
        TP_TEplus.set( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK );
        TP_TEplus.set( AnimationPropertiesKeys.FONT_PROPERTY, new Font("SansSerif", Font.PLAIN, 14) );

        TP_matrix = new TextProperties("MatrixData");
        TP_matrix.set( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK );
        TP_matrix.set( AnimationPropertiesKeys.FONT_PROPERTY, new Font("SansSerif", Font.PLAIN, 11) );

        RP_bgmatrix = new RectProperties("Background");
        RP_bgmatrix.set( AnimationPropertiesKeys.FILLED_PROPERTY, true );
        RP_bgmatrix.set( AnimationPropertiesKeys.DEPTH_PROPERTY, 16 );
        RP_bgmatrix.set( AnimationPropertiesKeys.FILL_PROPERTY, Color.WHITE );
        RP_bgmatrix.set( AnimationPropertiesKeys.COLOR_PROPERTY, Color.WHITE );

        RP_titlebox = new RectProperties("TitleBox");
        RP_titlebox.set( AnimationPropertiesKeys.FILLED_PROPERTY, true );
        RP_titlebox.set( AnimationPropertiesKeys.DEPTH_PROPERTY, 2 );
        RP_titlebox.set( AnimationPropertiesKeys.FILL_PROPERTY, new Color(80, 160, 255) );

        SP_phases = new SourceCodeProperties("PhasesCode");
        SP_phases.set( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK );
        SP_phases.set( AnimationPropertiesKeys.FONT_PROPERTY, new Font("SansSerif", Font.PLAIN, 16));
        SP_phases.set( AnimationPropertiesKeys.HIGHLIGHTCOLOR_PROPERTY, Color.BLUE );

        SP_code = new SourceCodeProperties("PhasesCode");
        SP_code.set( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK );
        SP_code.set( AnimationPropertiesKeys.HIGHLIGHTCOLOR_PROPERTY, Color.BLUE );

        AP_sourcedata = new ArrayProperties("ArrayData");
        AP_sourcedata.set( AnimationPropertiesKeys.DEPTH_PROPERTY, 8);
        AP_sourcedata.set( AnimationPropertiesKeys.FILL_PROPERTY, Color.WHITE);
        AP_sourcedata.set( AnimationPropertiesKeys.CELLHIGHLIGHT_PROPERTY, Color.YELLOW);

        PP_IndexPointer = new PolylineProperties("IndexPointer");
        PP_IndexPointer.set( AnimationPropertiesKeys.DEPTH_PROPERTY, 4);
        PP_IndexPointer.set( AnimationPropertiesKeys.FWARROW_PROPERTY, true);

        MP_mapentry = new MatrixProperties("MapEntry");
        MP_mapentry.set( AnimationPropertiesKeys.FONT_PROPERTY, new Font("SansSerif", Font.PLAIN, 10));
        MP_mapentry.set( AnimationPropertiesKeys.DEPTH_PROPERTY, 16);
        MP_mapentry.set( AnimationPropertiesKeys.GRID_ALIGN_PROPERTY, "center");
        MP_mapentry.set( AnimationPropertiesKeys.GRID_STYLE_PROPERTY, "plain");
        MP_mapentry.set( AnimationPropertiesKeys.CELL_WIDTH_PROPERTY, 8);
        MP_mapentry.set( AnimationPropertiesKeys.CELL_HEIGHT_PROPERTY, 2);

        localTimer_250ms = new MsTiming(250);

        localFormat = new DecimalFormat("#.####", DecimalFormatSymbols.getInstance( Locale.ENGLISH ));
    }

    @Override
    public String generate(AnimationPropertiesContainer props, Hashtable<String, Object> primitives) {
    	window_size_y = (Integer)primitives.get("window_size_y");
        window_size_x = (Integer)primitives.get("window_size_x");
        plain_xdata = (int[])primitives.get("xdata");
        plain_ydata = (int[])primitives.get("ydata");
        
        AP_sourcedata = (ArrayProperties)props.getPropertiesByName("source_arrays");
        code = (SourceCodeProperties)props.getPropertiesByName("code");
        
        GenerateTEScript();
        
        return lang.toString();
    }

    protected int[] FGetXSource() {
        return plain_xdata;
    }

    protected int[] FGetYSource() {
        return plain_ydata;
    }

    protected int getXWindowSize() {
        return window_size_x;
    }

    protected int getYWindowSize() {
        return window_size_y;
    }

    protected void FGenerateTEHeader(Language AScript) {
        TitleText = AScript.newText( new Coordinates(16, 16), "TransferEntropy in C++", "header", null, TP_title);
        AScript.addItem( TitleText );

        TitleBox = AScript.newRect( new Offset(-4, -4, "header", "NW"), new Offset(4, 4, "header", "SE"), "hRect", null, RP_titlebox );
        AScript.addItem( TitleBox );

        ListTitle.add(TitleText);
        ListTitle.add(TitleBox);
        
        SourceCode init_description = AScript.newSourceCode( new Offset(0, 40, "header", "SW"), "description", null, SP_phases);
        init_description.addMultilineCode( getDescription(), "desc_all", Timing.INSTANTEOUS);
        AScript.nextStep("Introduction");
        
        init_description.hide();
    }

	protected void FGenerateTEMainCode(Language AScript) {
        SPhaseCode = AScript.newSourceCode( new Offset(160, 0, "hRect", "NE"), "mainSteps", null, SP_phases);
        SPhaseCode.addCodeLine("1. Slide the window through the data rows and create the maps.", "phase_1", 0, Timing.INSTANTEOUS);
        SPhaseCode.addCodeLine("2. Calculate probabilities for each XY1 Window.", "phase_2", 0, Timing.INSTANTEOUS);
        SPhaseCode.addCodeLine("3. Finalize calculation", "phase_3", 0, Timing.INSTANTEOUS);

        AScript.addItem(SPhaseCode);
        AScript.nextStep();

        SPhaseCode.highlight(0);
    }

    protected void FShowTEMainCodeAgain(Language AScript) {
        SPhaseCode.unhighlight(0);
        SPhaseCode.highlight(1);
    }

    protected void FGenerateTEMapGen(Language AScript) {
        // Subtitle:
        SubTitleText = AScript.newText( new Offset(0, 16, "header", "SW"), "1. Generate Maps", "subheader", null, TP_subtitle);
        AScript.addItem( SubTitleText );

        SubTitleBox = AScript.newRect( new Offset(-4, 0, "subheader", "NW"), new Offset(4, 0, "subheader", "SE"), "subhRect1", null, RP_titlebox );
        AScript.addItem( SubTitleBox );

        // Source Data:
        xdata = AScript.newIntArray( new Offset(0, 64, "subheader", "SW"), FGetXSource(), "xdata", null, AP_sourcedata);
        ydata = AScript.newIntArray( new Offset(0, 4, "xdata", "SW"), FGetYSource(), "ydata", null, AP_sourcedata);

        // Infos:
        AScript.addItem( AScript.newText( new Offset(0, 4, "ydata", "SW"), "length: " + xdata.getLength(), "info_len", null, TP_datainfo ) );
        bucket_count = (xdata.getLength() - Math.max(getXWindowSize(), getYWindowSize()));
        bucketText = AScript.newText( new Offset(16, 0, "info_len", "NE"), "buckets: " + String.valueOf(bucket_count), "info_buckets", null, TP_datainfo );
        AScript.addItem( bucketText );
        AScript.addItem( AScript.newText( new Offset(16, 0, "info_buckets", "NE"), "window-sizes: (" + getXWindowSize() + ", " + getYWindowSize() + ")", "info_wsize", null, TP_datainfo) );

        // Maps:
        AScript.addItem( AScript.newText( new Offset(0, 16, "info_len", "SW"), "XY1 Map = ", "map_xy1", null, TP_datainfo) );
        AScript.addItem( AScript.newText( new Offset(0, 50, "map_xy1", "NW"),  "XY Map = " , "map_xy" , null, TP_datainfo) );
        AScript.addItem( AScript.newText( new Offset(0, 50, "map_xy", "NW"),   "Y1 Map = " , "map_y1" , null, TP_datainfo) );
        AScript.addItem( AScript.newText( new Offset(0, 50, "map_y1", "NW"),   "Y Map = "  , "map_y"  , null, TP_datainfo) );

        SourceCode SCurCode = AScript.newSourceCode( new Offset(0, 90, "map_y1", "NW"), "code_1", null, SP_code );
        SCurCode.addMultilineCode(
          "for (unsigned int i = start_index; i < (data_size - 1); i++) {\n" +
            "  // add the xn...x1 and yn...y1 information to the respective window data\n" +
            "  for (unsigned int j = 0; j < window_size_from; j++) { // read data from x row      \n" +
            "    xy_window.data[j] = x[i-j]; \n" +
            "    xy1_window.data[j] = x[i-j]; \n" +
            "  }\n" +
            "  for (unsigned int j = 0; j < window_size_to; j++) { // read data from y row\n" +
            "    y_window.data[j] = y[i-j]; \n" +
            "    y1_window.data[j] = y[i-j]; \n" +
            "    xy_window.data[j+window_size_from] = y[i-j];\n" +
            "    xy1_window.data[j+window_size_from] = y[i-j];\n" +
            "  }\n" +
            "  // Add the n+1 information\n" +
            "  y1_window.data[window_size_to] = y[i + 1];\n" +
            "  xy1_window.data[window_size_from + window_size_to] = y[i + 1];\n" +
            " \n" +
            "  // Add the windows to the maps, if they do not exist in the map yet, a new field with value 1 is generated for it.\n" +
            "  xy1_probabilities[xy1_window]++; \n" +
            "  xy_probabilities[xy_window]++;\n" +
            "  y1_probabilities[y1_window]++;\n" +
            "  y_probabilities[y_window]++;\n" +
            "}", "code_1_label", Timing.INSTANTEOUS);

        // Map Brackets:
        String MapXY1_LastID = "xy1p_open";
        AScript.addItem( AScript.newText( new Offset(16, 0, "map_xy1", "NE"), "{", MapXY1_LastID, null, TP_datainfo) );
        String MapXY_LastID = "xyp_open";
        AScript.addItem( AScript.newText( new Offset(16, 50, "map_xy1", "NE"), "{", MapXY_LastID, null, TP_datainfo) );
        String MapY1_LastID = "y1p_open";
        AScript.addItem( AScript.newText( new Offset(16, 100, "map_xy1", "NE"), "{", MapY1_LastID, null, TP_datainfo) );
        String MapY_LastID = "yp_open";
        AScript.addItem( AScript.newText( new Offset(16, 150, "map_xy1", "NE"), "{", MapY_LastID, null, TP_datainfo) );

        Text MapXY1_Closer = AScript.newText( new Offset(20, 0, "map_xy1", "NE"), "}", "xy1p_close", null, TP_datainfo);
        AScript.addItem( MapXY1_Closer );
        Text MapXY_Closer = AScript.newText( new Offset(20, 50, "map_xy1", "NE"), "}", "xyp_close", null, TP_datainfo);
        AScript.addItem( MapXY_Closer );
        Text MapY1_Closer = AScript.newText( new Offset(20, 100, "map_xy1", "NE"), "}", "y1p_close", null, TP_datainfo);
        AScript.addItem( MapY1_Closer );
        Text MapY_Closer = AScript.newText( new Offset(20, 150, "map_xy1", "NE"), "}", "yp_close", null, TP_datainfo);
        AScript.addItem( MapY_Closer );

        AScript.nextStep("Phase 1: Map Generation");

        // Generate Arrow:
        IndexPointer = AScript.newPolyline( new Node[]{ new Offset(-2, -50, "xdata[0]", "NW"), new Offset(-2, 0, "xdata[0]", "NW") }, "l_datapos", null, PP_IndexPointer);
        AScript.addItem( IndexPointer );

        xy1_list = new LinkedList<TEPair<List<Integer>, Integer>>();
        xy1_texts = new LinkedList<Text>();
        xy1_grids = new LinkedList<TEPair<List<Text>, Rect>>();

        xy_list = new LinkedList<TEPair<List<Integer>, Integer>>();
        xy_texts = new LinkedList<Text>();
        xy_grids = new LinkedList<TEPair<List<Text>, Rect>>();

        y1_list = new LinkedList<TEPair<List<Integer>, Integer>>();
        y1_texts = new LinkedList<Text>();
        y1_grids = new LinkedList<TEPair<List<Text>, Rect>>();

        y_list = new LinkedList<TEPair<List<Integer>, Integer>>();
        y_texts = new LinkedList<Text>();
        y_grids = new LinkedList<TEPair<List<Text>, Rect>>();

        ArrayList<Integer> cbucket = new ArrayList<Integer>();

        Text activeText;

        int data_size = Math.min( xdata.getLength(), ydata.getLength() );
        int x_wsize = getXWindowSize();
        int y_wsize = getYWindowSize();
        int max_windowsize = Math.max(x_wsize, y_wsize);

        // Go through complete row:
        for (int i = max_windowsize-1; i < (data_size - 1); i++) {
            // 1. Unhighlight ArrayCells:
            xdata.unhighlightCell(0, xdata.getLength()-1, null, null);
            ydata.unhighlightCell(0, ydata.getLength()-1, null, null);
            AScript.nextStep();

            // 2. Move Cursor:
            IndexPointer.moveTo( null, null, new Offset(2, -50, "xdata[" + i + "]", "NE"), Timing.INSTANTEOUS, localTimer_250ms);
            TEUtil.newHighlight(SCurCode, 0, 0);
            AScript.nextStep();
            TEUtil.delHighlight(SCurCode, 0, 0);

            // 3. Highlight ArrayCells:
            xdata.highlightCell(i - (x_wsize - 1), i, null, null);
            ydata.highlightCell(i - (y_wsize - 1), i+1, null, null);
            TEUtil.newHighlight(SCurCode, 1, 14);
            AScript.nextStep();
            TEUtil.delHighlight(SCurCode, 1, 14);

            // 4. Copy values to maps:
            int QIndex;
            // 4.1 XY1Map:
            {
                // Generate Bucket:
                cbucket.clear();
                for (int j = 0; j < x_wsize; j++) { cbucket.add( xdata.getData(i - j)); }
                for (int j = 0; j < y_wsize; j++) { cbucket.add( ydata.getData(i - j)); }
                cbucket.add( ydata.getData(i + 1) );
                QIndex = TEUtil.IndexOf( xy1_list, cbucket );

                if (QIndex == -1) { // Create a new entry:
                    xy1_list.add( new TEPair<List<Integer>, Integer>( new ArrayList<Integer>(cbucket), 1) ); // add it to the source list

                    // Manage AnimalSCRIPT:
                    AScript.addItem( AScript.newText( new Offset(4, 0, MapXY1_LastID, "NE"), "(", "xy1p_elem" + i + "_openPair", null, TP_datainfo ) );

                    TEPair<TEPair<List<Text>, Rect>, Integer> text_grid = TEUtil.StringMatrixToTextFields( AScript, TEUtil.BucketXY1ToMatrix(cbucket, x_wsize, y_wsize), TP_matrix, RP_bgmatrix,
                      new Offset(3, 0, "xy1p_elem" + i + "_openPair", "NE"), "xy1p_elem" + i + "_graph" );
                    for (int j = 0; j < text_grid.getKey().getKey().size(); j++) {
                        AScript.addItem( text_grid.getKey().getKey().get(j) );
                    } AScript.addItem( text_grid.getKey().getValue() );
                    xy1_grids.add( text_grid.getKey() );

                    AScript.addItem( AScript.newText( new Offset(4 + text_grid.getValue(), 0, "xy1p_elem" + i + "_openPair", "NE"), ",", "xy1p_elem" + i + "_comma", null, TP_datainfo) );
                    Text cNum = AScript.newText( new Offset(4, 0, "xy1p_elem" + i + "_comma", "NE"), "1", "xy1p_elem" + i + "_N", null, TP_datainfo);
                    AScript.addItem( cNum ); xy1_texts.add( cNum ); activeText = cNum;
                    MapXY1_LastID = "xy1p_elem" + i + "_closePair";
                    AScript.addItem( AScript.newText( new Offset(11, 0, cNum, "NE"), ")", MapXY1_LastID, null, TP_datainfo) );
                    MapXY1_Closer.moveTo(null, null, new Offset(4, 0, MapXY1_LastID, "NE"), null, null);
                }
                else { // Update that entry:
                    xy1_list.set(QIndex, new TEPair<List<Integer>, Integer>( xy1_list.get(QIndex).getKey(), xy1_list.get(QIndex).getValue() + 1));
                    xy1_texts.get(QIndex).setText( String.valueOf( xy1_list.get(QIndex).getValue() ), null, null );
                    activeText = xy1_texts.get(QIndex);
                }
            }
            TEUtil.newHighlight(SCurCode, 17, 17);
            activeText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            AScript.nextStep();
            activeText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            TEUtil.delHighlight(SCurCode, 17, 17);

            // 4.2 XYMap:
            {
                // Generate Bucket:
                cbucket.clear();
                for (int j = 0; j < x_wsize; j++) { cbucket.add( xdata.getData(i - j)); }
                for (int j = 0; j < y_wsize; j++) { cbucket.add( ydata.getData(i - j)); }
                QIndex = TEUtil.IndexOf( xy_list, cbucket );

                if (QIndex == -1) { // Create a new entry:
                    xy_list.add( new TEPair<List<Integer>, Integer>( new ArrayList<Integer>(cbucket), 1) ); // add it to the source list

                    // Manage AnimalSCRIPT:
                    AScript.addItem( AScript.newText( new Offset(4, 0, MapXY_LastID, "NE"), "(", "xyp_elem" + i + "_openPair", null, TP_datainfo ) );

                    TEPair<TEPair<List<Text>, Rect>, Integer> text_grid = TEUtil.StringMatrixToTextFields( AScript, TEUtil.BucketXYToMatrix(cbucket, x_wsize, y_wsize), TP_matrix, RP_bgmatrix,
                      new Offset(3, 0, "xyp_elem" + i + "_openPair", "NE"), "xyp_elem" + i + "_graph" );
                    for (int j = 0; j < text_grid.getKey().getKey().size(); j++) {
                        AScript.addItem( text_grid.getKey().getKey().get(j) );
                    } AScript.addItem( text_grid.getKey().getValue() );
                    xy_grids.add( text_grid.getKey() );

                    AScript.addItem( AScript.newText( new Offset(4 + text_grid.getValue(), 0, "xyp_elem" + i + "_openPair", "NE"), ",", "xyp_elem" + i + "_comma", null, TP_datainfo) );
                    Text cNum = AScript.newText( new Offset(4, 0, "xyp_elem" + i + "_comma", "NE"), "1", "xyp_elem" + i + "_N", null, TP_datainfo);
                    AScript.addItem( cNum ); xy_texts.add( cNum ); activeText = cNum;
                    MapXY_LastID = "xyp_elem" + i + "_closePair";
                    AScript.addItem( AScript.newText( new Offset(11, 0, cNum, "NE"), ")", MapXY_LastID, null, TP_datainfo) );
                    MapXY_Closer.moveTo(null, null, new Offset(4, 0, MapXY_LastID, "NE"), null, null);
                }
                else { // Update that entry:
                    xy_list.set(QIndex, new TEPair<List<Integer>, Integer>( xy_list.get(QIndex).getKey(), xy_list.get(QIndex).getValue() + 1));
                    xy_texts.get(QIndex).setText( String.valueOf( xy_list.get(QIndex).getValue() ), null, null );
                    activeText = xy_texts.get(QIndex);
                }
            }
            TEUtil.newHighlight(SCurCode, 18, 18);
            activeText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            AScript.nextStep();
            activeText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            TEUtil.delHighlight(SCurCode, 18, 18);

            // 4.3 Y1Map:
            {
                // Generate Bucket:
                cbucket.clear();
                for (int j = 0; j < y_wsize; j++) { cbucket.add( ydata.getData(i - j)); }
                cbucket.add( ydata.getData(i + 1) );
                QIndex = TEUtil.IndexOf( y1_list, cbucket );

                if (QIndex == -1) { // Create a new entry:
                    y1_list.add( new TEPair<List<Integer>, Integer>( new ArrayList<Integer>(cbucket), 1) ); // add it to the source list

                    // Manage AnimalSCRIPT:
                    AScript.addItem( AScript.newText( new Offset(4, 0, MapY1_LastID, "NE"), "(", "y1p_elem" + i + "_openPair", null, TP_datainfo ) );

                    TEPair<TEPair<List<Text>, Rect>, Integer> text_grid = TEUtil.StringMatrixToTextFields( AScript, TEUtil.BucketY1ToMatrix(cbucket, x_wsize, y_wsize), TP_matrix, RP_bgmatrix,
                      new Offset(3, 0, "y1p_elem" + i + "_openPair", "NE"), "y1p_elem" + i + "_graph" );
                    for (int j = 0; j < text_grid.getKey().getKey().size(); j++) {
                        AScript.addItem( text_grid.getKey().getKey().get(j) );
                    } AScript.addItem( text_grid.getKey().getValue() );
                    y1_grids.add( text_grid.getKey() );

                    AScript.addItem( AScript.newText( new Offset(4 + text_grid.getValue(), 0, "y1p_elem" + i + "_openPair", "NE"), ",", "y1p_elem" + i + "_comma", null, TP_datainfo) );
                    Text cNum = AScript.newText( new Offset(4, 0, "y1p_elem" + i + "_comma", "NE"), "1", "y1p_elem" + i + "_N", null, TP_datainfo);
                    AScript.addItem( cNum ); y1_texts.add( cNum ); activeText = cNum;
                    MapY1_LastID = "y1p_elem" + i + "_closePair";
                    AScript.addItem( AScript.newText( new Offset(11, 0, cNum, "NE"), ")", MapY1_LastID, null, TP_datainfo) );
                    MapY1_Closer.moveTo(null, null, new Offset(4, 0, MapY1_LastID, "NE"), null, null);
                }
                else { // Update that entry:
                    y1_list.set(QIndex, new TEPair<List<Integer>, Integer>( y1_list.get(QIndex).getKey(), y1_list.get(QIndex).getValue() + 1));
                    y1_texts.get(QIndex).setText( String.valueOf( y1_list.get(QIndex).getValue() ), null, null );
                    activeText = y1_texts.get(QIndex);
                }
            }
            TEUtil.newHighlight(SCurCode, 19, 19);
            activeText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            AScript.nextStep();
            activeText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            TEUtil.delHighlight(SCurCode, 19, 19);

            // 4.4 YMap:
            {
                // Generate Bucket:
                cbucket.clear();
                for (int j = 0; j < y_wsize; j++) { cbucket.add( ydata.getData(i - j)); }
                QIndex = TEUtil.IndexOf( y_list, cbucket );

                if (QIndex == -1) { // Create a new entry:
                    y_list.add( new TEPair<List<Integer>, Integer>( new ArrayList<Integer>(cbucket), 1) ); // add it to the source list

                    // Manage AnimalSCRIPT:
                    AScript.addItem( AScript.newText( new Offset(4, 0, MapY_LastID, "NE"), "(", "yp_elem" + i + "_openPair", null, TP_datainfo ) );

                    TEPair<TEPair<List<Text>, Rect>, Integer> text_grid = TEUtil.StringMatrixToTextFields( AScript, TEUtil.BucketYToMatrix(cbucket, x_wsize, y_wsize), TP_matrix, RP_bgmatrix,
                      new Offset(3, 0, "yp_elem" + i + "_openPair", "NE"), "yp_elem" + i + "_graph" );
                    for (int j = 0; j < text_grid.getKey().getKey().size(); j++) {
                        AScript.addItem( text_grid.getKey().getKey().get(j) );
                    } AScript.addItem( text_grid.getKey().getValue() );
                    y_grids.add( text_grid.getKey() );

                    AScript.addItem( AScript.newText( new Offset(4 + text_grid.getValue(), 0, "yp_elem" + i + "_openPair", "NE"), ",", "yp_elem" + i + "_comma", null, TP_datainfo) );
                    Text cNum = AScript.newText( new Offset(4, 0, "yp_elem" + i + "_comma", "NE"), "1", "yp_elem" + i + "_N", null, TP_datainfo);
                    AScript.addItem( cNum ); y_texts.add( cNum ); activeText = cNum;
                    MapY_LastID = "yp_elem" + i + "_closePair";
                    AScript.addItem( AScript.newText( new Offset(11, 0, cNum, "NE"), ")", MapY_LastID, null, TP_datainfo) );
                    MapY_Closer.moveTo(null, null, new Offset(4, 0, MapY_LastID, "NE"), null, null);
                }
                else { // Update that entry:
                    y_list.set(QIndex, new TEPair<List<Integer>, Integer>( y_list.get(QIndex).getKey(), y_list.get(QIndex).getValue() + 1));
                    y_texts.get(QIndex).setText( String.valueOf( y_list.get(QIndex).getValue() ), null, null );
                    activeText = y_texts.get(QIndex);
                }
            }
            TEUtil.newHighlight(SCurCode, 20, 20);
            activeText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            AScript.nextStep();
            activeText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            TEUtil.delHighlight(SCurCode, 20, 20);
        }
        IndexPointer.hide();
        xdata.unhighlightCell(0, xdata.getLength()-1, null, null);
        ydata.unhighlightCell(0, ydata.getLength()-1, null, null);
        SCurCode.hide();
        AScript.nextStep();
    }

    protected void FGenerateTESummation(Language AScript) {
        SubTitleText.hide();
        SubTitleText = AScript.newText(new Offset(0, 16, "header", "SW"), "2. Accumulate the probabilities", "subheader2", null, TP_subtitle);
        AScript.addItem( SubTitleText );
        SubTitleBox.hide();
        SubTitleBox = AScript.newRect( new Offset(-4, 0, "subheader2", "NW"), new Offset(4, 0, "subheader2", "SE"), "subhRect2", null, RP_titlebox );
        AScript.addItem( SubTitleBox );

        Text accTEPreText = AScript.newText( new Offset(0, 45, "map_y", "NW"), "accTE = ", "acclabel", null, TP_TEacc);
        AScript.addItem( accTEPreText );
        accTEText = AScript.newText( new Offset(25, 0, "acclabel", "NE"), "0.0", "accTE", null, TP_TEacc );
        Text plusTEText = AScript.newText( new Offset(40, 0, "accTE", "NE"), "", "accTE", null, TP_TEplus );
        plusTEText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
        plusTEText.hide();

        SourceCode SCurCode =  AScript.newSourceCode( new Offset(0, 120, "map_y1", "NW"), "code_2", null, SP_code );
        SCurCode.addMultilineCode(
          "double accTE = 0.0;\n" +
            "// Iterate over all existing states (xyn1 windows)\n" +
            "for(map_iterator it=xy1_probabilities.begin(); it!=xy1_probabilities.end(); it++) {\n" +
            "  // Recreate the corresponding windows to get the respective information from the maps\n" +
            "  for(unsigned int i = 0; i < window_size_from; i++) {\n" +
            "    xy_window.data[i] = (*it).first.data[i];\n" +
            "  } \n" +
            "  for(unsigned int i = 0; i < window_size_to; i++) {\n" +
            "    y_window.data[i] = (*it).first.data[i+window_size_from];\n" +
            "    y1_window.data[i] = (*it).first.data[i+window_size_from];      \n" +
            "    xy_window.data[i+window_size_from] = (*it).first.data[i+window_size_from];\n" +
            "  }\n" +
            "  y1_window.data[window_size_to] = (*it).first.data[window_size_from + window_size_to];\n" +
            " \n" +
            "  // Calculate the Transfer Entropy\n" +
            "  // Add the new information to the sum\n" +
            "  accTE = accTE + ((\n" +
            "   (double) (*it).second) * log2((\n" +
            "     (double) (*it).second * (double) y_probabilities[y_window]\n" +
            "     ) / (\n" +
            "     (double) xy_probabilities[xy_window] * (double) y1_probabilities[y1_window]\n" +
            "     )));\n" +
            "}", "code_2_label", Timing.INSTANTEOUS);

        TEUtil.newHighlight(SCurCode, 0, 0);
        AScript.nextStep("Phase 2: Accumulation of probabilities");
        TEUtil.delHighlight(SCurCode, 0, 0);

        List<Integer> xy1_bucket;

        double ld_factor = 1/Math.log(2.0);

        int wsize_x = getXWindowSize();
        int wsize_y = getYWindowSize();

        double accTE = 0.0;

        for (int i = 0; i < xy1_list.size(); i++) {
            xy1_bucket = xy1_list.get(i).getKey();
            double xy1_c = xy1_list.get(i).getValue();
            double xy_c, y1_c, y_c;
            int xy_index, y1_index, y_index;

            xy1_grids.get(i).getValue().changeColor( AnimationPropertiesKeys.FILL_PROPERTY, Color.YELLOW, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            xy1_texts.get(i).changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            TEUtil.newHighlight(SCurCode, 1, 1);
            AScript.nextStep();
            TEUtil.delHighlight(SCurCode, 1, 1);

            List<Integer> xy_bucket = new ArrayList<Integer>();
            List<Integer> y1_bucket = new ArrayList<Integer>();
            List<Integer> y_bucket = new ArrayList<Integer>();

            // Recreate the windows:
            for (int j = 0; j < wsize_x; j++) {
                xy_bucket.add( xy1_bucket.get(j) );
            }
            for (int j = 0; j < wsize_y; j++) {
                y_bucket.add( xy1_bucket.get(j + wsize_x) );
                y1_bucket.add( xy1_bucket.get(j + wsize_x) );
                xy_bucket.add( xy1_bucket.get(j + wsize_x) );
            }
            y1_bucket.add( xy1_bucket.get( wsize_x + wsize_y ) );

            TEUtil.newHighlight(SCurCode, 2, 12);
            xy_index = TEUtil.IndexOf( xy_list, xy_bucket );
            xy_grids.get(xy_index).getValue().changeColor( AnimationPropertiesKeys.FILL_PROPERTY, Color.YELLOW, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            xy_texts.get(xy_index).changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            AScript.nextStep();
            xy_c = xy_list.get( xy_index ).getValue() ;

            y1_index = TEUtil.IndexOf( y1_list, y1_bucket );
            y1_grids.get(y1_index).getValue().changeColor( AnimationPropertiesKeys.FILL_PROPERTY, Color.YELLOW, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            y1_texts.get(y1_index).changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            AScript.nextStep();
            y1_c = y1_list.get( y1_index ).getValue() ;

            y_index = TEUtil.IndexOf( y_list, y_bucket );
            y_grids.get(y_index).getValue().changeColor( AnimationPropertiesKeys.FILL_PROPERTY, Color.YELLOW, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            y_texts.get(y_index).changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            AScript.nextStep();
            y_c = y_list.get( y_index ).getValue() ;
            TEUtil.delHighlight(SCurCode, 2, 12);

            TEUtil.newHighlight(SCurCode, 16, 21);
            plusTEText.show();
            plusTEText.setText("+[" + xy1_c + " * log_2( (" + xy1_c + " * " + y_c + ") / (" + xy_c + " * " + y1_c + ") ) ]", Timing.INSTANTEOUS, Timing.INSTANTEOUS);
            AScript.nextStep();

            double nextVal = xy1_c * (Math.log(
              (xy1_c * y_c)
                /
                (xy_c * y1_c)
            ) * ld_factor);

            accTE += nextVal;

            plusTEText.setText("+[ " + xy1_c + " * log_2( " + (xy1_c * y_c) + " / " + (xy_c * y1_c) + " ) ]", Timing.INSTANTEOUS, Timing.INSTANTEOUS);
            AScript.nextStep();

            plusTEText.setText("+[ " + xy1_c + " * log_2( " + ((xy1_c * y_c) / (xy_c * y1_c)) + " ) ]", Timing.INSTANTEOUS, Timing.INSTANTEOUS);
            AScript.nextStep();

            plusTEText.setText("+[ " + localFormat.format(nextVal) + " ]", Timing.INSTANTEOUS, Timing.INSTANTEOUS);
            AScript.nextStep();

            plusTEText.hide();
            accTEText.setText(localFormat.format(accTE), Timing.INSTANTEOUS, Timing.INSTANTEOUS);

            xy1_grids.get(i).getValue().changeColor( AnimationPropertiesKeys.FILL_PROPERTY, Color.WHITE, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            xy1_texts.get(i).changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            xy_grids.get(xy_index).getValue().changeColor( AnimationPropertiesKeys.FILL_PROPERTY, Color.WHITE, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            xy_texts.get(xy_index).changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            y1_grids.get(y1_index).getValue().changeColor( AnimationPropertiesKeys.FILL_PROPERTY, Color.WHITE, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            y1_texts.get(y1_index).changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            y_grids.get(y_index).getValue().changeColor( AnimationPropertiesKeys.FILL_PROPERTY, Color.WHITE, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
            y_texts.get(y_index).changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.BLACK, Timing.INSTANTEOUS, Timing.INSTANTEOUS );

            AScript.nextStep();
            TEUtil.delHighlight(SCurCode, 16, 21);
        }

        SCurCode.hide();
        SCurCode = AScript.newSourceCode( new Offset(0, 120, "map_y1", "NW"), "code_2", null, SP_code );
        SCurCode.addCodeLine( "TE = accTE / (data_size - max_window_size);", "Finalize", 0, Timing.INSTANTEOUS );
        SPhaseCode.toggleHighlight(1,2);
        SubTitleText.hide();
        SubTitleText = AScript.newText(new Offset(0, 16, "header", "SW"), "3. Divide by amount of buckets", "subheader3", null, TP_subtitle);
        AScript.addItem( SubTitleText );
        SubTitleBox.hide();
        SubTitleBox = AScript.newRect( new Offset(-4, 0, "subheader3", "NW"), new Offset(4, 0, "subheader3", "SE"), "subhRect3", null, RP_titlebox );
        AScript.addItem( SubTitleBox );
        AScript.nextStep("Phase 3: Finalization");

        accTEText.setText( localFormat.format(accTE) + " / " + localFormat.format(bucket_count) , Timing.INSTANTEOUS, Timing.INSTANTEOUS);
        accTEPreText.setText( "TE = ", Timing.INSTANTEOUS, Timing.INSTANTEOUS);
        bucketText.changeColor( AnimationPropertiesKeys.COLOR_PROPERTY, Color.RED, Timing.INSTANTEOUS, Timing.INSTANTEOUS );
        AScript.nextStep();

        accTEText.setText( localFormat.format(accTE / bucket_count), Timing.INSTANTEOUS, Timing.INSTANTEOUS);
        AScript.nextStep();
        
        SourceCode finalText = AScript.newSourceCode( new Offset(0, 50, accTEText.getName(), "SW"), "final_te_meaning", null, SP_phases);
        finalText.addMultilineCode("The system of data row x influences in average " + localFormat.format(accTE / bucket_count) + " Bits" +
                                   "\n" + "of data row y.", "last", Timing.INSTANTEOUS);
    }

    public Language GenerateTEScript() {
        lang.setStepMode(true);

        // Step 1: Title
        FGenerateTEHeader(lang);
        // lang.nextStep();

        // Step 2: Code:
        FGenerateTEMainCode(lang);
        lang.nextStep();

        // Step 3: Phase 1
        FGenerateTEMapGen(lang);
        lang.nextStep();

        // Step 4:
        FShowTEMainCodeAgain(lang);

        FGenerateTESummation(lang);
        lang.nextStep();

        return lang;
    }

    @Override
    public String getName() {
        return "Transfer Entropy";
    }

    @Override
    public String getAlgorithmName() {
        return "Transfer Entropy";
    }

    @Override
    public String getAnimationAuthor() {
        return "Kenten Fina";
    }
    
    @Override
    public String getDescription() {
		return "The transfer entropy quantifies the flow of information from one system to another. "
				 +"\n"
				 +" \n"
				 +"It is calculated in two steps. At first, a window of a specific size is slid through the data rows,"
				 +"\n"
				 +"counting the amount of appearances of each window. The window contains elements of the past"
				 +"\n"
				 +"of both data rows according to the window-size and one additional element of the second data row. The "
				 +"\n"
				 +"idea behind the transfer-entropy is to find out how often that additional value has a certain value, "
				 +"\n"
				 +"after a given past, in contrast to other values."
				 +"\n"
				 +"After that, you calculate the information flow for each window the algorithm has found. This is done"
				 +"\n"
				 +"in such a way, that it is assured that a found regularity is not just a regularity from the second data row"
				 +"\n"
				 +"itself but also an influence from the first data row to the first one."
				 +"\n"
				 +" \n"
				 +"The calculation shown in this animation follows the given description and is based on the following"
				 +"\n"
				 +"formula given in the description of this animation from the paper 'Distinguishing Anticipation from Causality'."
		         +"\n"
		         +"Source: http://journals.aps.org/prl/pdf/10.1103/PhysRevLett.107.128701";
	}

    @Override
    public String getCodeExample(){
        return "template <class Policy>"
 +"\n"
 +"  double transfer_entropy_internal(const std::vector<unsigned int>& x,"
 +"\n"
 +"                                  const std::vector<unsigned int>& y,"
 +"\n"
 +"                                  size_t dynamic_window_size_from = 0,"
 +"\n"
 +"                                  size_t dynamic_window_size_to = 0) {"
 +"\n"
 +"  // Maps used as probability storage."
 +"\n"
 +"  // The DynamicWindowPolicy uses static_size = 0, so this data will not be used if a dynamic window size is used."
 +"\n"
 +"  std::map<typename Policy::short_window_t, unsigned int> y_probabilities;"
 +"\n"
 +"  std::map<typename Policy::long_window_t, unsigned int> xy_probabilities;"
 +"\n"
 +"  std::map<typename Policy::short1_window_t, unsigned int> y1_probabilities;"
 +"\n"
 +"  std::map<typename Policy::long1_window_t, unsigned int> xy1_probabilities;"
 +"\n"
 +"\n"
 +"  // The probability windows"
 +"\n"
 +"  // for static windows, dynamic_window_size is 0, so no data is used."
 +"\n"
 +"  typename Policy::short_window_t y_window(dynamic_window_size_to);"
 +"\n"
 +"  typename Policy::long_window_t xy_window(dynamic_window_size_from + dynamic_window_size_to);"
 +"\n"
 +"  typename Policy::short1_window_t y1_window(dynamic_window_size_to+1);"
 +"\n"
 +"  typename Policy::long1_window_t xy1_window(dynamic_window_size_from + dynamic_window_size_to+1);"
 +"\n"
 +"\n"
 +"  // setup some global variables:"
 +"\n"
 +"  unsigned int data_size = x.size();"
 +"\n"
 +"  "
 +"\n"
 +"  // setup the window sizes:"
 +"\n"
 +"  size_t window_size_from = (dynamic_window_size_from != 0 ? dynamic_window_size_from : Policy::static_window_size_from);"
 +"\n"
 +"  size_t window_size_to = (dynamic_window_size_to != 0 ? dynamic_window_size_to : Policy::static_window_size_to);"
 +"\n"
 +"  size_t max_window_size = (window_size_from > window_size_to ? window_size_from : window_size_to);"
 +"\n"
 +"\n"
 +"  // The size of the input vectors must be equal and the window_size must be"
 +"\n"
 +"  // smaller than the input vectors size."
 +"\n"
 +"  if(x.size() != y.size() || window_size_from >= data_size || window_size_to >= data_size)"
 +"\n"
 +"    return -2.0;"
 +"\n"
 +"\n"
 +"  // only one direction is calculated for this, because xy and yx maps are not the same for m != n."
 +"\n"
 +"  double Res;"
 +"\n"
 +"\n"
 +"  // Later used for log operation with basis 2"
 +"\n"
 +"  double l2 = log(2.0);"
 +"\n"
 +"\n"
 +"  // Ty->x"
 +"\n"
 +"  // Init Result"
 +"\n"
 +"  double Txy = 0.0;"
 +"\n"
 +"\n"
 +"  typedef typename std::map<typename Policy::long1_window_t, unsigned int>::iterator map_iterator;"
 +"\n"
 +"\n"
 +"  // Tx->y"
 +"\n"
 +"  // Calculate the Probabilities"
 +"\n"
 +"  "
 +"\n"
 +"  int start_index = max_window_size;"
 +"\n"
 +"  //int window_to_offset = window_size_from - window_size_to;"
 +"\n"
 +"\n"
 +"  // Let the sliding window iterate over the available states."
 +"\n"
 +"  // i = start point of the window"
 +"\n"
 +"  for (unsigned int i = start_index-1; i < (data_size - 1); i++) {"
 +"\n"
 +"    // add the xn...x1 and yn...y1 information to the respective window data"
 +"\n"
 +"    for (unsigned int j = 0; j < window_size_from; j++) { // read data from x row      "
 +"\n"
 +"      xy_window.data[j] = x[i-j]; "
 +"\n"
 +"      xy1_window.data[j] = x[i-j]; "
 +"\n"
 +"    }"
 +"\n"
 +"    for (unsigned int j = 0; j < window_size_to; j++) { // read data from y row"
 +"\n"
 +"      y_window.data[j] = y[i-j]; "
 +"\n"
 +"      y1_window.data[j] = y[i-j]; "
 +"\n"
 +"      xy_window.data[j+window_size_from] = y[i-j];"
 +"\n"
 +"      xy1_window.data[j+window_size_from] = y[i-j];"
 +"\n"
 +"    }"
 +"\n"
 +"    // Add the n+1 information"
 +"\n"
 +"    y1_window.data[window_size_to] = y[i + 1];"
 +"\n"
 +"    xy1_window.data[window_size_from + window_size_to] = y[i + 1];"
 +"\n"
 +"\n"
 +"    // Add the windows to the maps"
 +"\n"
 +"    // Add (y1...yn)"
 +"\n"
 +"    y_probabilities[y_window]++;"
 +"\n"
 +"    // Add (y1...yn,yn+1)"
 +"\n"
 +"    y1_probabilities[y1_window]++;"
 +"\n"
 +"    // Add (x1...xn,y1...yn)"
 +"\n"
 +"    xy_probabilities[xy_window]++;"
 +"\n"
 +"    // Add (x1...xn,y1...yn,yn+1)"
 +"\n"
 +"    xy1_probabilities[xy1_window]++;"
 +"\n"
 +"  }"
 +"\n"
 +"\n"
 +"  // Iterate over all existing states (xyn1 windows)"
 +"\n"
 +"  for(map_iterator it=xy1_probabilities.begin(); it!=xy1_probabilities.end(); ++it) {"
 +"\n"
 +"\n"
 +"    // Recreate the corresponding windows to get the respective information from the maps"
 +"\n"
 +"    for(unsigned int i = 0; i < window_size_from; i++) {"
 +"\n"
 +"      xy_window.data[i] = (*it).first.data[i];"
 +"\n"
 +"    } "
 +"\n"
 +"    for(unsigned int i = 0; i < window_size_to; i++) {"
 +"\n"
 +"      y_window.data[i] = (*it).first.data[i+window_size_from];"
 +"\n"
 +"      y1_window.data[i] = (*it).first.data[i+window_size_from];      "
 +"\n"
 +"      xy_window.data[i+window_size_from] = (*it).first.data[i+window_size_from];"
 +"\n"
 +"    }"
 +"\n"
 +"    y1_window.data[window_size_to] = (*it).first.data[window_size_from + window_size_to];"
 +"\n"
 +"\n"
 +"    // Calculate the Transfer Entropy"
 +"\n"
 +"    // Add the new information to the sum"
 +"\n"
 +"    Txy = Txy + (("
 +"\n"
 +"     (double) (*it).second) * log2(("
 +"\n"
 +"       (double) (*it).second * (double) y_probabilities[y_window]"
 +"\n"
 +"       ) / ("
 +"\n"
 +"       (double) xy_probabilities[xy_window] * (double) y1_probabilities[y1_window]"
 +"\n"
 +"       )));"
 +"\n"
 +"  }"
 +"\n"
 +"  Res = Txy / (data_size - max_window_size);"
 +"\n"
 +"\n"
 +"  return Res;"
 +"\n"
 +"}";
    }

    @Override
    public String getFileExtension(){
        return "asu";
    }

    @Override
    public Locale getContentLocale() {
        return Locale.ENGLISH;
    }

    @Override
    public GeneratorType getGeneratorType() {
        return new GeneratorType(GeneratorType.GENERATOR_TYPE_MATHS);
    }

    @Override
    public String getOutputLanguage() {
        return "C";
    }

    @Override
    public boolean validateInput(AnimationPropertiesContainer animationPropertiesContainer, Hashtable<String, Object> hashtable) throws IllegalArgumentException {
        int custom_window_size_y = (Integer)hashtable.get("window_size_y");
        int custom_window_size_x = (Integer)hashtable.get("window_size_x");
        int[] custom_xdata = (int[])hashtable.get("xdata");
        int[] custom_ydata = (int[])hashtable.get("ydata");

        if (custom_xdata.length != custom_ydata.length) return false;
        if (custom_window_size_x >= custom_xdata.length) return false;
        if (custom_window_size_y >= custom_xdata.length) return false;

        return true;
    }
}