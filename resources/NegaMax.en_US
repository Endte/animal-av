noSuchKeyException=Es gibt keine Ressource f\u00fcr Eintrag {0}
iconNotFound=Icon ”{0}” not found
algorithmName=NegaMax Algorithm
generatorName=NegaMax [EN]
description[0]=The NegaMax algorithm [1] is a search method from the game theory, that operates on a 2-player zero-sum game [2] and is visualized as a game tree.
description[1]=A zero-sum game describes a game in which the sum of the winnings and losses of all players, here 2, taken together gives 0.
description[2]=The algorithm calculates the optimal turn strategy for the starting player, assuming that both players perfom optimal and perfect moves.
description[3]=This means that both players make no mistakes and always choose the move with the best value for them.
description[4]=NegaMax is based on the MiniMax [3] (or MinMax) algorithm, but exploits the fact that max(a,b) = -min(-a,-b). This simplifies the implementation compared to the MinMax algorithm.
description[5]=[1] https://en.wikipedia.org/wiki/Negamax
description[6]=[2] https://en.wikipedia.org/wiki/Zero-sum_game
description[7]=[3] https://en.wikipedia.org/wiki/Minimax
sourcecode=sourcecode
animationstart=animationstart
summary=summary
actualPlayer=Player's turn:
outro[0]=The algorithm terminates with the value:
outro[1]=This means that the player
outro[2]=will achieve the value
outro[3]= , assuming that both players play optimally.
outro[4]=Despite the small game tree, the algorithm takes quite a long time to find a solution.
outro[5]=The runtime is O(|V| + |E| + C) where |V| is the number of nodes, |E| the number of edges and C the number of comparisons.
outro[6]=Hence, the NegaMax algorithm's runtime is comparable to the depth first search.
outro[7]=To use NegaMax effectively, there are several heuristic methods:
outro[8]=   1. NegaMax with alpha-beta Pruning
outro[9]=   2. NegaMax with alpha-beta Pruning and Transposition Tables
outro[10]=See: https://en.wikipedia.org/wiki/Negamax
descFile[0]=The NegaMax algorithm [1] is a search method from the game theory, that operates on a 2-player zero-sum game [2] and is visualized as a game tree. A zero-sum game describes a game in which the sum of the winning and losses of all players, here 2, taken together gives 0.
descFile[1]=\n
descFile[2]=The algorithm calculates the optimal turn strategy for the starting player, assuming that both players perform optimal and perfect moves.
descFile[3]=\n
descFile[4]=This means that both players make no mistakes and always choose the move with the best value for them.
descFile[5]=\n
descFile[6]=NegaMax is based on the MiniMax [3] (or MinMax) algorithm, but exploits the fact that max(a,b) = -min(-a,-b). This simplifies the implementation compared to the Minimax algorithm.
descFile[7]=\n
descFile[8]=\n
descFile[9]=[1] https://en.wikipedia.org/wiki/Negamax
descFile[10]=\n
descFile[11]=[2] https://en.wikipedia.org/wiki/Zero-sum_game
descFile[12]=\n
descFile[13]=[3] https://en.wikipedia.org/wiki/Minimax
descFile[14]=\n\n
intermission=In the following, the gametree and startplayer shall have the following values: \n
descFile[15]=The treestructure is defined as follows: root
descFile[16]=childNode1
descFile[17]=childNode1.1
descFile[18]=leaf1.1.1 leaf1.1.2 } childNode1.2
descFile[19]=leaf1.2.1 leaf 1.2.2 } } childNode2
descFile[20]=leaf 2.1 leaf 2.2 } }
descFile[21]=\n
descFile[22]=Note that childNode must be a letter and leaf a positive integer. Another example: A
descFile[23]=B
descFile[24]=1 13 4 } C
descFile[25]=3 6 8 } D
descFile[26]=9 5 14 } }
descFile[27]=\n
descFile[28]=The startplayer must have either the value 1 for MAX or -1 for MIN.
parseError[0]=Error parsing the tree. \n
parseError[1]=\n\n Entered tree: \n
parseError[2]=\n\n In addition, the starting player must be 1 for MAX or -1 for MIN. Entered value: \n
parseError[3]=Starting player must be either 1 for MAX or -1 for MIN. Entered value: \n
startPlayer=Starting player
question[0]=Who is the starting player?
questionFeedbackT[0.0]=Correct, it's MAX player's turn. He tries to maximize his childnodes' values.
questionFeedback[0.0]= Wrong! MAX would have been correct!
questionFeedbackT[0.1]=Correct, it's MIN player's turn. He tries to minimize his childnodes' values.
questionFeedback[0.1]= Wrong! It is MIN's turn!
question[1]=Which complexity class does the algorithm have?
questionFeedbackT[1.0]=Correct! The complexity class is comparable to the depth first search!
questionFeedback[1.1]=Wrong. O(|V|+|E|+C) would have been right!
question[2]=Which assumption makes the algorithm more efficient than the MinMax algorithm?
questionFeedbackT[2.0]=Correct!
questionFeedback[2.1]=Wrong. max(a,b)=-min(-a,-b) would have been correct!
question[3]=Which value did the starting player achieve?
questionFeedbackT[3.0]=Correct!
questionFeedback[3.1]=Wrong!