# By Max Kaiser (c) 2018

noSuchKeyException=Es existiert keine Ressource f\u00fcr den Key{0}
2 iconNotFound=Icon ” {0} ” nicht gefunden

### Ä -> \u00c4 ###
### ä -> \u00e4 ###
### Ö -> \u00d6 ###
### ö -> \u00f6 ### 
### Ü -> \u00dc ###
### ü -> \u00fc ###
### ß -> \u00df ###

#### Animal GUI Text ####
description = Fast Inverse Square Root:\n\nA mathematic algorithm with a very important past in the graphical computing.\n\nThis algorithm was used in many applications where a fast calculation of the multiplicative inverse of the square root is important. For example the calculation of the light reflection in computer games like Quake 3 or real time rendering of 3D models.\nBut it is not easy to understand the mechanism even though there are only a view lines of code.\n\n But with graphical elements and a step by step explanation it is possible to understand the algorithm really fast.

#### Introduction ####
intro.titleA = What is the Fast Inverse Square Root algorithm?
intro.text1  = It is a algorithm which was really important in the past tense to calculate fast and efficient the multiplicative inverse
intro.text2  = of a square root. To do this the mathematic function f(x) = 1 / sqrt(x) will be approximated.
intro.titleB = Where was this algorithm used and why was it so important?
intro.text3  = Because of the speed and good accuracy even in the first iteration it was and also will be used in everything
intro.text4  = that goes in the direction of graphical computing. So also it is used in computer games lake Quake 3, where is
intro.text5  = was first get attention. But the algorithm is older and was used before (1990-2000) in different variations.
intro.titleC = How does the algorithm work?
intro.text6  = There are two main parts the algorithm consists of:
intro.text7  = 1) the first approximation using a magic number.
intro.text8  = 2) after that newton's method of approximation is used.
intro.text9  = For that there is a funktion used to calculate the error of a guessed value and the orginal number.
intro.text10 =      f(x) = 1 / (g^2)   -  x  (insert in Newton's method will give us the formula used in the algorithm)



#### GUI Introduction ####
gui.intro.description      = Description
gui.intro.descriotion.text = Now a short explanation where you can see which data:
gui.intro.text1            = - on the left side is the source code of the algorithm
gui.intro.title1           = Algorithm
gui.intro.text2            = - next to that are the current values as float
gui.intro.title2           = Float Value
gui.intro.text3            = - And on the right is the y value as binary representation
gui.intro.title3           = Value in binary
gui.intro.tip              = ***  It is usefull to enlarge the Animal window  ***


#### GUI ####
array.title = Value as IEEE 754 representation


#### Algorithmus ####
call.text1 = In the variable x is the starting value onto which the algorithm is applied.
call.text2 = So this is the x to calculate 1/ sqrt(x).

threehalves.text1 = The value 1.5 is generated by the use of the Newtons method of approximation where
threehalves.text2 = we also get the formula to calculate the new y value in each iteration..

half_x.text1 = The other constant value in the formula is the half of the orginal number.
half_x.text2 = This expression (also 0.5*x) is also generated (like the 1.5) from the Newtons method.
half_x.text3 = We have Newton approximation for the square root of the function of x:
half_x.text4 = new_x = x - (f(x) - f'(x)) and f(x) = 1 / g^2  - x  so g is a guess of 1/sqrt(x).
half_x.text5 = Now there is our error function f(x) (Error between x and our guess)
half_x.text6 = If we apply the Newtons method we get the formula used in the algorithm.

magicnumber.text1 = The magic number is THE central functionality of the algorithm because
magicnumber.text2 = it is a punctilious approximation for every possible float value.
magicnumber.text3 = But the magic number does not change for each x.
magicnumber.text4 = In the public development of this algorithm there where multiple different
magicnumber.text5 = magic numbers found with the only different of the accuracy of the first approximation. 
magicnumber.text6 = For double precision there must be used a other magic number.
magicnumber.text7 = Later it will be shown how the magic number and the shift will react.

floatasbits.text1 = To use the trick with the shift we first must convert the float value
floatasbits.text2 = as a bit representation.
floatasbits.text3 = Using floatToIntBits(a) we get the bit representation for the float a.
floatasbits.text4 = But we can't save this directly in Java because the type bit ore bit array does not exsist.
floatasbits.text5 = So we save is as an Integer which is exactly the same when we shift.

magicshift.text1 = To understand what's the reason for us to shift everything to the right we first must recall that
magicshift.text2 = a floating point value is saved normalized with splitted exponent and bias.
magicshift.text3 = So if we shift to the right we cut in half both of them. 
magicshift.text4 = Bias and Exponent both decreases by the half.
magicshift.text5 = After that we subtract the value from our magic number.
magicshift.text6 = But remember it is right now a integer / binary number not a float!

bitsasfloat.text = To get back the float value form the binary representation we reverse the penultimate step.

lasty.text1 = The do while loop starts.
lasty.text2 = In each iteration we calculate a new approximation of x.
lasty.text3 = the abort condition is that we reached the limit of float and cant save more precised numbers.
lasty.text4 = So we calculate new values until we can't recognize any difference.

calculation.text1 = We do one step of newton's method of approximation and get so a new and more accurate value.
calculation.text2 = That also means that the error in our error function f(x) decreases. See also explanation of how we
calculation.text3 = get to the formula half_x = 0.5*x.

check.text1 = To know if we can stop jet (it is the case if we reached our limit for float, we can also use
check.text2 = double as the datatype to get more accurate) we take the difference of our current approximation y
check.text3 = and the one of the previous calculation. Mostly after two ore three iterations the result will not change any more.

finish.text1 = We finished and can return the result.
finish.text2 = And this was much faster that comparable algorithms from 1990-2000 that was used :)


#### Questions ####
question.text1   = Mark all answers that are correct.
question.answ1.1 = The formula   new = old - ( f(x) / Df(x) ) is used.
question.answ1.2 = A approximation is f(x) = (1 / guess^2 ) - x
question.answ1.3 = The magic number is unique.
question.answ1.4 = Graphical applications use this algorithm.
question.feed1.1 = 1) Thats right cause its the general formal of Newtons method.\r\n
question.feed1.2 = 2) Thats correct, it is our error function.\r\n
question.feed1.3 = 3) Wrong because over the time a view magic numbers has been discovered.\r\n
question.feed1.4 = 4) Yes, really important for the calculation of light reflection.\r\n
question.text2   = In which direction do we shift in the next statement?
question.answ2.1 = shift to the right
question.answ2.2 = shift to the left
question.feed2.1 = Correct we shift to the right for one location.
question.feed2.2 = Wrong. We do not shift to the left. This is a shift to the right.

question.text3   = Now we reached the abort condition for another time. Do we run for one more iteration or are we leaving the mein loop? (false = leave, true = keep running)\nTip: look at the variable window in Animal. (Not the variables shown in the GUI)

#### Error Messages ####
validate.floattobig   = The entered floating point number is too big for the datatype float.
validate.floattosmall = The entered floating point number is too small for the datatype float.
validate.magicnumber  = Sorry but the entered Magic number is too big to use it later as an Integer for calculation. 

#### Final Frame ####
final.title.text = Final
final.text       = We finished the run through the algorithm and needed for the calculation
final.text2      = Iterations.
final.text2b     = We approximated with this initial values:
final.text2c     = Input value for the formula:
final.text2d     = Fixed magic number:
final.text2e     = The following outputs:
final.text3      = Our approximated y:
final.text4      = Comparison value using Java Math:














